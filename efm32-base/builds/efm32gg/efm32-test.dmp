
efm32-test:     file format elf32-littlearm


Disassembly of section .text:

00000000 <__Vectors>:
       0:	20020000 	.word	0x20020000
       4:	000003d5 	.word	0x000003d5
       8:	00000401 	.word	0x00000401
       c:	00000401 	.word	0x00000401
      10:	00000401 	.word	0x00000401
      14:	00000401 	.word	0x00000401
      18:	00000401 	.word	0x00000401
      1c:	00000401 	.word	0x00000401
      20:	00000401 	.word	0x00000401
      24:	00000401 	.word	0x00000401
      28:	00000401 	.word	0x00000401
      2c:	00000401 	.word	0x00000401
      30:	00000401 	.word	0x00000401
      34:	00000401 	.word	0x00000401
      38:	00000401 	.word	0x00000401
      3c:	00000205 	.word	0x00000205
      40:	00000401 	.word	0x00000401
      44:	00000401 	.word	0x00000401
      48:	00000401 	.word	0x00000401
      4c:	00000401 	.word	0x00000401
      50:	00000401 	.word	0x00000401
      54:	00000401 	.word	0x00000401
      58:	00000401 	.word	0x00000401
      5c:	00000401 	.word	0x00000401
      60:	00000401 	.word	0x00000401
      64:	0000034d 	.word	0x0000034d
      68:	00000401 	.word	0x00000401
      6c:	00000401 	.word	0x00000401
      70:	00000401 	.word	0x00000401
      74:	00000401 	.word	0x00000401
      78:	00000401 	.word	0x00000401
      7c:	00000401 	.word	0x00000401
      80:	00000401 	.word	0x00000401
      84:	00000401 	.word	0x00000401
      88:	00000401 	.word	0x00000401
      8c:	00000401 	.word	0x00000401
      90:	00000401 	.word	0x00000401
      94:	00000401 	.word	0x00000401
      98:	00000401 	.word	0x00000401
      9c:	00000401 	.word	0x00000401
      a0:	00000401 	.word	0x00000401
      a4:	00000401 	.word	0x00000401
      a8:	00000401 	.word	0x00000401
      ac:	00000401 	.word	0x00000401
      b0:	00000401 	.word	0x00000401
      b4:	00000401 	.word	0x00000401
      b8:	0000031d 	.word	0x0000031d
      bc:	00000401 	.word	0x00000401
      c0:	00000401 	.word	0x00000401
      c4:	00000401 	.word	0x00000401
      c8:	00000401 	.word	0x00000401
      cc:	00000401 	.word	0x00000401
      d0:	00000401 	.word	0x00000401
      d4:	00000401 	.word	0x00000401
      d8:	00000401 	.word	0x00000401

000000dc <__do_global_dtors_aux>:
      dc:	b510      	push	{r4, lr}
      de:	4c05      	ldr	r4, [pc, #20]	; (f4 <__do_global_dtors_aux+0x18>)
      e0:	7823      	ldrb	r3, [r4, #0]
      e2:	b933      	cbnz	r3, f2 <__do_global_dtors_aux+0x16>
      e4:	4b04      	ldr	r3, [pc, #16]	; (f8 <__do_global_dtors_aux+0x1c>)
      e6:	b113      	cbz	r3, ee <__do_global_dtors_aux+0x12>
      e8:	4804      	ldr	r0, [pc, #16]	; (fc <__do_global_dtors_aux+0x20>)
      ea:	f3af 8000 	nop.w
      ee:	2301      	movs	r3, #1
      f0:	7023      	strb	r3, [r4, #0]
      f2:	bd10      	pop	{r4, pc}
      f4:	20000078 	.word	0x20000078
      f8:	00000000 	.word	0x00000000
      fc:	00001084 	.word	0x00001084

00000100 <frame_dummy>:
     100:	4b08      	ldr	r3, [pc, #32]	; (124 <frame_dummy+0x24>)
     102:	b510      	push	{r4, lr}
     104:	b11b      	cbz	r3, 10e <frame_dummy+0xe>
     106:	4908      	ldr	r1, [pc, #32]	; (128 <frame_dummy+0x28>)
     108:	4808      	ldr	r0, [pc, #32]	; (12c <frame_dummy+0x2c>)
     10a:	f3af 8000 	nop.w
     10e:	4808      	ldr	r0, [pc, #32]	; (130 <frame_dummy+0x30>)
     110:	6803      	ldr	r3, [r0, #0]
     112:	b903      	cbnz	r3, 116 <frame_dummy+0x16>
     114:	bd10      	pop	{r4, pc}
     116:	4b07      	ldr	r3, [pc, #28]	; (134 <frame_dummy+0x34>)
     118:	2b00      	cmp	r3, #0
     11a:	d0fb      	beq.n	114 <frame_dummy+0x14>
     11c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     120:	4718      	bx	r3
     122:	bf00      	nop
     124:	00000000 	.word	0x00000000
     128:	2000007c 	.word	0x2000007c
     12c:	00001084 	.word	0x00001084
     130:	20000074 	.word	0x20000074
     134:	00000000 	.word	0x00000000

00000138 <_mainCRTStartup>:
     138:	4b15      	ldr	r3, [pc, #84]	; (190 <_mainCRTStartup+0x58>)
     13a:	2b00      	cmp	r3, #0
     13c:	bf08      	it	eq
     13e:	4b13      	ldreq	r3, [pc, #76]	; (18c <_mainCRTStartup+0x54>)
     140:	469d      	mov	sp, r3
     142:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
     146:	2100      	movs	r1, #0
     148:	468b      	mov	fp, r1
     14a:	460f      	mov	r7, r1
     14c:	4813      	ldr	r0, [pc, #76]	; (19c <_mainCRTStartup+0x64>)
     14e:	4a14      	ldr	r2, [pc, #80]	; (1a0 <_mainCRTStartup+0x68>)
     150:	1a12      	subs	r2, r2, r0
     152:	f000 ff7f 	bl	1054 <memset>
     156:	4b0f      	ldr	r3, [pc, #60]	; (194 <_mainCRTStartup+0x5c>)
     158:	2b00      	cmp	r3, #0
     15a:	d000      	beq.n	15e <_mainCRTStartup+0x26>
     15c:	4798      	blx	r3
     15e:	4b0e      	ldr	r3, [pc, #56]	; (198 <_mainCRTStartup+0x60>)
     160:	2b00      	cmp	r3, #0
     162:	d000      	beq.n	166 <_mainCRTStartup+0x2e>
     164:	4798      	blx	r3
     166:	2000      	movs	r0, #0
     168:	2100      	movs	r1, #0
     16a:	0004      	movs	r4, r0
     16c:	000d      	movs	r5, r1
     16e:	480d      	ldr	r0, [pc, #52]	; (1a4 <_mainCRTStartup+0x6c>)
     170:	2800      	cmp	r0, #0
     172:	d002      	beq.n	17a <_mainCRTStartup+0x42>
     174:	480c      	ldr	r0, [pc, #48]	; (1a8 <_mainCRTStartup+0x70>)
     176:	f3af 8000 	nop.w
     17a:	f000 ff45 	bl	1008 <__libc_init_array>
     17e:	0020      	movs	r0, r4
     180:	0029      	movs	r1, r5
     182:	f000 f871 	bl	268 <main>
     186:	f000 ff2b 	bl	fe0 <exit>
     18a:	bf00      	nop
     18c:	00080000 	.word	0x00080000
     190:	20020000 	.word	0x20020000
	...
     19c:	20000078 	.word	0x20000078
     1a0:	200000ac 	.word	0x200000ac
	...

000001ac <SYSTEM_GetProdRev>:
 * @return
 *   Production revision for this part.
 ******************************************************************************/
__STATIC_INLINE uint8_t SYSTEM_GetProdRev(void)
{
  return (DEVINFO->PART & _DEVINFO_PART_PROD_REV_MASK)
     1ac:	4b03      	ldr	r3, [pc, #12]	; (1bc <SYSTEM_GetProdRev+0x10>)
     1ae:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
     1b0:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
         >> _DEVINFO_PART_PROD_REV_SHIFT;
     1b4:	0e1b      	lsrs	r3, r3, #24
 * @return
 *   Production revision for this part.
 ******************************************************************************/
__STATIC_INLINE uint8_t SYSTEM_GetProdRev(void)
{
  return (DEVINFO->PART & _DEVINFO_PART_PROD_REV_MASK)
     1b6:	b2db      	uxtb	r3, r3
         >> _DEVINFO_PART_PROD_REV_SHIFT;
}
     1b8:	4618      	mov	r0, r3
     1ba:	4770      	bx	lr
     1bc:	0fe081b0 	.word	0x0fe081b0

000001c0 <CHIP_Init>:
 * This init function will configure the device to a state where it is
 * as similar as later revisions as possible, to improve software compatibility
 * with newer parts. See the device specific errata for details.
 *****************************************************************************/
__STATIC_INLINE void CHIP_Init(void)
{
     1c0:	b500      	push	{lr}
     1c2:	b083      	sub	sp, #12
  /* Fix for errata CMU_E113. */

  uint8_t                     prodRev;
  SYSTEM_ChipRevision_TypeDef chipRev;

  prodRev = SYSTEM_GetProdRev();
     1c4:	f7ff fff2 	bl	1ac <SYSTEM_GetProdRev>
     1c8:	4603      	mov	r3, r0
     1ca:	f88d 3007 	strb.w	r3, [sp, #7]
  SYSTEM_ChipRevisionGet(&chipRev);
     1ce:	ab01      	add	r3, sp, #4
     1d0:	4618      	mov	r0, r3
     1d2:	f000 fec7 	bl	f64 <SYSTEM_ChipRevisionGet>

  if ((prodRev >= 16) && (chipRev.minor >= 3)) {
     1d6:	f89d 3007 	ldrb.w	r3, [sp, #7]
     1da:	2b0f      	cmp	r3, #15
     1dc:	d90b      	bls.n	1f6 <CHIP_Init+0x36>
     1de:	f89d 3004 	ldrb.w	r3, [sp, #4]
     1e2:	2b02      	cmp	r3, #2
     1e4:	d907      	bls.n	1f6 <CHIP_Init+0x36>
    /* This fixes an issue with the LFXO on high temperatures. */
    *(volatile uint32_t*)0x400C80C0 =
     1e6:	4a06      	ldr	r2, [pc, #24]	; (200 <CHIP_Init+0x40>)
      (*(volatile uint32_t*)0x400C80C0 & ~(1 << 6) ) | (1 << 4);
     1e8:	4b05      	ldr	r3, [pc, #20]	; (200 <CHIP_Init+0x40>)
     1ea:	681b      	ldr	r3, [r3, #0]
     1ec:	f023 0350 	bic.w	r3, r3, #80	; 0x50
     1f0:	f043 0310 	orr.w	r3, r3, #16
  prodRev = SYSTEM_GetProdRev();
  SYSTEM_ChipRevisionGet(&chipRev);

  if ((prodRev >= 16) && (chipRev.minor >= 3)) {
    /* This fixes an issue with the LFXO on high temperatures. */
    *(volatile uint32_t*)0x400C80C0 =
     1f4:	6013      	str	r3, [r2, #0]
#endif

#if defined(_EFR_DEVICE) && (_SILICON_LABS_GECKO_INTERNAL_SDID >= 84)
  MSC->CTRL |= 0x1 << 8;
#endif
}
     1f6:	bf00      	nop
     1f8:	b003      	add	sp, #12
     1fa:	f85d fb04 	ldr.w	pc, [sp], #4
     1fe:	bf00      	nop
     200:	400c80c0 	.word	0x400c80c0

00000204 <SysTick_Handler>:

#include "i2c.h"

volatile uint32_t msTicks;
void delay(uint32_t dlyTicks);
void SysTick_Handler(void) {msTicks++;}
     204:	4b03      	ldr	r3, [pc, #12]	; (214 <SysTick_Handler+0x10>)
     206:	681b      	ldr	r3, [r3, #0]
     208:	3301      	adds	r3, #1
     20a:	4a02      	ldr	r2, [pc, #8]	; (214 <SysTick_Handler+0x10>)
     20c:	6013      	str	r3, [r2, #0]
     20e:	bf00      	nop
     210:	4770      	bx	lr
     212:	bf00      	nop
     214:	20000098 	.word	0x20000098

00000218 <blink>:

    curTicks = msTicks;
    while ((msTicks - curTicks) < dlyTicks) ;
}

void blink() {
     218:	b500      	push	{lr}
     21a:	b083      	sub	sp, #12
	volatile long i;
	volatile long sleep_time = 1000000;
     21c:	4b11      	ldr	r3, [pc, #68]	; (264 <blink+0x4c>)
     21e:	9300      	str	r3, [sp, #0]
	while(1) {
		GPIO_PinModeSet(gpioPortE, 2, gpioModePushPull, 1);
     220:	2301      	movs	r3, #1
     222:	2204      	movs	r2, #4
     224:	2102      	movs	r1, #2
     226:	2004      	movs	r0, #4
     228:	f000 fe00 	bl	e2c <GPIO_PinModeSet>
		for(i = 0; i < sleep_time; i++);
     22c:	2300      	movs	r3, #0
     22e:	9301      	str	r3, [sp, #4]
     230:	e002      	b.n	238 <blink+0x20>
     232:	9b01      	ldr	r3, [sp, #4]
     234:	3301      	adds	r3, #1
     236:	9301      	str	r3, [sp, #4]
     238:	9a01      	ldr	r2, [sp, #4]
     23a:	9b00      	ldr	r3, [sp, #0]
     23c:	429a      	cmp	r2, r3
     23e:	dbf8      	blt.n	232 <blink+0x1a>
		GPIO_PinModeSet(gpioPortE, 2, gpioModePushPull, 0);
     240:	2300      	movs	r3, #0
     242:	2204      	movs	r2, #4
     244:	2102      	movs	r1, #2
     246:	2004      	movs	r0, #4
     248:	f000 fdf0 	bl	e2c <GPIO_PinModeSet>
		for(i = 0; i < sleep_time; i++);
     24c:	2300      	movs	r3, #0
     24e:	9301      	str	r3, [sp, #4]
     250:	e002      	b.n	258 <blink+0x40>
     252:	9b01      	ldr	r3, [sp, #4]
     254:	3301      	adds	r3, #1
     256:	9301      	str	r3, [sp, #4]
     258:	9a01      	ldr	r2, [sp, #4]
     25a:	9b00      	ldr	r3, [sp, #0]
     25c:	429a      	cmp	r2, r3
     25e:	dbf8      	blt.n	252 <blink+0x3a>
	}
     260:	e7de      	b.n	220 <blink+0x8>
     262:	bf00      	nop
     264:	000f4240 	.word	0x000f4240

00000268 <main>:
		}
		EMU_EnterEM2(false);
	}
}

int main(void) {
     268:	b508      	push	{r3, lr}
	CHIP_Init();
     26a:	f7ff ffa9 	bl	1c0 <CHIP_Init>
	CMU_ClockEnable(cmuClock_GPIO, true);
     26e:	2101      	movs	r1, #1
     270:	4803      	ldr	r0, [pc, #12]	; (280 <main+0x18>)
     272:	f000 fb69 	bl	948 <CMU_ClockEnable>
	//test_i2c();
	blink();
     276:	f7ff ffcf 	bl	218 <blink>
     27a:	2300      	movs	r3, #0
}
     27c:	4618      	mov	r0, r3
     27e:	bd08      	pop	{r3, pc}
     280:	0004d200 	.word	0x0004d200

00000284 <NVIC_DisableIRQ>:
  \brief   Disable External Interrupt
  \details Disables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
     284:	b082      	sub	sp, #8
     286:	4603      	mov	r3, r0
     288:	f88d 3007 	strb.w	r3, [sp, #7]
  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
     28c:	4908      	ldr	r1, [pc, #32]	; (2b0 <NVIC_DisableIRQ+0x2c>)
     28e:	f99d 3007 	ldrsb.w	r3, [sp, #7]
     292:	095b      	lsrs	r3, r3, #5
     294:	f89d 2007 	ldrb.w	r2, [sp, #7]
     298:	f002 021f 	and.w	r2, r2, #31
     29c:	2001      	movs	r0, #1
     29e:	fa00 f202 	lsl.w	r2, r0, r2
     2a2:	3320      	adds	r3, #32
     2a4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
     2a8:	bf00      	nop
     2aa:	b002      	add	sp, #8
     2ac:	4770      	bx	lr
     2ae:	bf00      	nop
     2b0:	e000e100 	.word	0xe000e100

000002b4 <I2C_IntClear>:
 * @param[in] flags
 *   Pending I2C interrupt source to clear. Use a bitwse logic OR combination of
 *   valid interrupt flags for the I2C module (I2C_IF_nnn).
 ******************************************************************************/
__STATIC_INLINE void I2C_IntClear(I2C_TypeDef *i2c, uint32_t flags)
{
     2b4:	b082      	sub	sp, #8
     2b6:	9001      	str	r0, [sp, #4]
     2b8:	9100      	str	r1, [sp, #0]
  i2c->IFC = flags;
     2ba:	9b01      	ldr	r3, [sp, #4]
     2bc:	9a00      	ldr	r2, [sp, #0]
     2be:	631a      	str	r2, [r3, #48]	; 0x30
}
     2c0:	bf00      	nop
     2c2:	b002      	add	sp, #8
     2c4:	4770      	bx	lr
     2c6:	bf00      	nop

000002c8 <I2C_IntDisable>:
 * @param[in] flags
 *   I2C interrupt sources to disable. Use a bitwise logic OR combination of
 *   valid interrupt flags for the I2C module (I2C_IF_nnn).
 ******************************************************************************/
__STATIC_INLINE void I2C_IntDisable(I2C_TypeDef *i2c, uint32_t flags)
{
     2c8:	b082      	sub	sp, #8
     2ca:	9001      	str	r0, [sp, #4]
     2cc:	9100      	str	r1, [sp, #0]
  i2c->IEN &= ~(flags);
     2ce:	9b01      	ldr	r3, [sp, #4]
     2d0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
     2d2:	9b00      	ldr	r3, [sp, #0]
     2d4:	43db      	mvns	r3, r3
     2d6:	401a      	ands	r2, r3
     2d8:	9b01      	ldr	r3, [sp, #4]
     2da:	635a      	str	r2, [r3, #52]	; 0x34
}
     2dc:	bf00      	nop
     2de:	b002      	add	sp, #8
     2e0:	4770      	bx	lr
     2e2:	bf00      	nop

000002e4 <RTC_IntClear>:
 *   RTC interrupt sources to clear. Use a set of interrupt flags OR-ed
 *   together to clear multiple interrupt sources for the RTC module
 *   (RTC_IFS_nnn).
 ******************************************************************************/
__STATIC_INLINE void RTC_IntClear(uint32_t flags)
{
     2e4:	b082      	sub	sp, #8
     2e6:	9001      	str	r0, [sp, #4]
  RTC->IFC = flags;
     2e8:	4a02      	ldr	r2, [pc, #8]	; (2f4 <RTC_IntClear+0x10>)
     2ea:	9b01      	ldr	r3, [sp, #4]
     2ec:	6193      	str	r3, [r2, #24]
}
     2ee:	bf00      	nop
     2f0:	b002      	add	sp, #8
     2f2:	4770      	bx	lr
     2f4:	40080000 	.word	0x40080000

000002f8 <disableI2CInterrupts>:
	I2C_IntClear(I2C0, I2C_IEN_ADDR | I2C_IEN_RXDATAV | I2C_IEN_SSTOP);
	I2C_IntEnable(I2C0, I2C_IEN_ADDR | I2C_IEN_RXDATAV | I2C_IEN_SSTOP);
	NVIC_EnableIRQ(I2C0_IRQn);
}

void disableI2CInterrupts() {
     2f8:	b508      	push	{r3, lr}
	NVIC_DisableIRQ(I2C0_IRQn);
     2fa:	2009      	movs	r0, #9
     2fc:	f7ff ffc2 	bl	284 <NVIC_DisableIRQ>
	I2C_IntDisable(I2C0, I2C_IEN_ADDR | I2C_IEN_RXDATAV | I2C_IEN_SSTOP);
     300:	4904      	ldr	r1, [pc, #16]	; (314 <disableI2CInterrupts+0x1c>)
     302:	4805      	ldr	r0, [pc, #20]	; (318 <disableI2CInterrupts+0x20>)
     304:	f7ff ffe0 	bl	2c8 <I2C_IntDisable>
	I2C_IntClear(I2C0, I2C_IEN_ADDR | I2C_IEN_RXDATAV | I2C_IEN_SSTOP);
     308:	4902      	ldr	r1, [pc, #8]	; (314 <disableI2CInterrupts+0x1c>)
     30a:	4803      	ldr	r0, [pc, #12]	; (318 <disableI2CInterrupts+0x20>)
     30c:	f7ff ffd2 	bl	2b4 <I2C_IntClear>
}
     310:	bf00      	nop
     312:	bd08      	pop	{r3, pc}
     314:	00010024 	.word	0x00010024
     318:	4000a000 	.word	0x4000a000

0000031c <RTC_IRQHandler>:
	NVIC_EnableIRQ(RTC_IRQn);

	RTC_Init(&rtcInit);
}

void RTC_IRQHandler() {
     31c:	b508      	push	{r3, lr}
	RTC_IntClear(RTC_IFC_COMP0);
     31e:	2002      	movs	r0, #2
     320:	f7ff ffe0 	bl	2e4 <RTC_IntClear>
	if(!i2c_rxInProgress) {
     324:	4b07      	ldr	r3, [pc, #28]	; (344 <RTC_IRQHandler+0x28>)
     326:	781b      	ldrb	r3, [r3, #0]
     328:	b2db      	uxtb	r3, r3
     32a:	f083 0301 	eor.w	r3, r3, #1
     32e:	b2db      	uxtb	r3, r3
     330:	2b00      	cmp	r3, #0
     332:	d004      	beq.n	33e <RTC_IRQHandler+0x22>
		disableI2CInterrupts();
     334:	f7ff ffe0 	bl	2f8 <disableI2CInterrupts>
		i2c_startTx = true;
     338:	4b03      	ldr	r3, [pc, #12]	; (348 <RTC_IRQHandler+0x2c>)
     33a:	2201      	movs	r2, #1
     33c:	701a      	strb	r2, [r3, #0]
	}
}
     33e:	bf00      	nop
     340:	bd08      	pop	{r3, pc}
     342:	bf00      	nop
     344:	20000094 	.word	0x20000094
     348:	20000095 	.word	0x20000095

0000034c <I2C0_IRQHandler>:

void I2C0_IRQHandler() {
     34c:	b500      	push	{lr}
     34e:	b083      	sub	sp, #12
	int status = I2C0->IF;
     350:	4b1c      	ldr	r3, [pc, #112]	; (3c4 <I2C0_IRQHandler+0x78>)
     352:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     354:	9301      	str	r3, [sp, #4]
	if(status & I2C_IF_ADDR) {
     356:	9b01      	ldr	r3, [sp, #4]
     358:	f003 0304 	and.w	r3, r3, #4
     35c:	2b00      	cmp	r3, #0
     35e:	d009      	beq.n	374 <I2C0_IRQHandler+0x28>
		i2c_rxInProgress = true;
     360:	4b19      	ldr	r3, [pc, #100]	; (3c8 <I2C0_IRQHandler+0x7c>)
     362:	2201      	movs	r2, #1
     364:	701a      	strb	r2, [r3, #0]
		I2C0->RXDATA;
     366:	4b17      	ldr	r3, [pc, #92]	; (3c4 <I2C0_IRQHandler+0x78>)
     368:	69db      	ldr	r3, [r3, #28]
		I2C_IntClear(I2C0, I2C_IFC_ADDR);
     36a:	2104      	movs	r1, #4
     36c:	4815      	ldr	r0, [pc, #84]	; (3c4 <I2C0_IRQHandler+0x78>)
     36e:	f7ff ffa1 	bl	2b4 <I2C_IntClear>
     372:	e012      	b.n	39a <I2C0_IRQHandler+0x4e>
	} else if(status & I2C_IF_RXDATAV) {
     374:	9b01      	ldr	r3, [sp, #4]
     376:	f003 0320 	and.w	r3, r3, #32
     37a:	2b00      	cmp	r3, #0
     37c:	d00d      	beq.n	39a <I2C0_IRQHandler+0x4e>
		i2c_rxBuffer[i2c_rxBufferIndex] = I2C0->RXDATA;
     37e:	4b13      	ldr	r3, [pc, #76]	; (3cc <I2C0_IRQHandler+0x80>)
     380:	781b      	ldrb	r3, [r3, #0]
     382:	461a      	mov	r2, r3
     384:	4b0f      	ldr	r3, [pc, #60]	; (3c4 <I2C0_IRQHandler+0x78>)
     386:	69db      	ldr	r3, [r3, #28]
     388:	b2d9      	uxtb	r1, r3
     38a:	4b11      	ldr	r3, [pc, #68]	; (3d0 <I2C0_IRQHandler+0x84>)
     38c:	5499      	strb	r1, [r3, r2]
		i2c_rxBufferIndex++;
     38e:	4b0f      	ldr	r3, [pc, #60]	; (3cc <I2C0_IRQHandler+0x80>)
     390:	781b      	ldrb	r3, [r3, #0]
     392:	3301      	adds	r3, #1
     394:	b2da      	uxtb	r2, r3
     396:	4b0d      	ldr	r3, [pc, #52]	; (3cc <I2C0_IRQHandler+0x80>)
     398:	701a      	strb	r2, [r3, #0]
	}

	if(status & I2C_IEN_SSTOP) {
     39a:	9b01      	ldr	r3, [sp, #4]
     39c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
     3a0:	2b00      	cmp	r3, #0
     3a2:	d00a      	beq.n	3ba <I2C0_IRQHandler+0x6e>
		I2C_IntClear(I2C0, I2C_IEN_SSTOP);
     3a4:	f44f 3180 	mov.w	r1, #65536	; 0x10000
     3a8:	4806      	ldr	r0, [pc, #24]	; (3c4 <I2C0_IRQHandler+0x78>)
     3aa:	f7ff ff83 	bl	2b4 <I2C_IntClear>
		i2c_rxInProgress = false;
     3ae:	4b06      	ldr	r3, [pc, #24]	; (3c8 <I2C0_IRQHandler+0x7c>)
     3b0:	2200      	movs	r2, #0
     3b2:	701a      	strb	r2, [r3, #0]
		i2c_rxBufferIndex = 0;
     3b4:	4b05      	ldr	r3, [pc, #20]	; (3cc <I2C0_IRQHandler+0x80>)
     3b6:	2200      	movs	r2, #0
     3b8:	701a      	strb	r2, [r3, #0]
	}
}
     3ba:	bf00      	nop
     3bc:	b003      	add	sp, #12
     3be:	f85d fb04 	ldr.w	pc, [sp], #4
     3c2:	bf00      	nop
     3c4:	4000a000 	.word	0x4000a000
     3c8:	20000094 	.word	0x20000094
     3cc:	2000009c 	.word	0x2000009c
     3d0:	200000a0 	.word	0x200000a0

000003d4 <Reset_Handler>:
    .align      2
    .globl      Reset_Handler
    .type       Reset_Handler, %function
Reset_Handler:
#ifndef __NO_SYSTEM_INIT
    ldr     r0, =SystemInit
     3d4:	4806      	ldr	r0, [pc, #24]	; (3f0 <Reset_Handler+0x1c>)
    blx     r0
     3d6:	4780      	blx	r0
 *    __data_start__: VMA of start of the section to copy to
 *    __data_end__: VMA of end of the section to copy to
 *
 *  All addresses must be aligned to 4 bytes boundary.
 */
    ldr     r1, =__etext
     3d8:	4906      	ldr	r1, [pc, #24]	; (3f4 <Reset_Handler+0x20>)
    ldr     r2, =__data_start__
     3da:	4a07      	ldr	r2, [pc, #28]	; (3f8 <Reset_Handler+0x24>)
    ldr     r3, =__data_end__
     3dc:	4b07      	ldr	r3, [pc, #28]	; (3fc <Reset_Handler+0x28>)

.L_loop1:
    cmp     r2, r3
     3de:	429a      	cmp	r2, r3
    ittt    lt
     3e0:	bfbe      	ittt	lt
    ldrlt   r0, [r1], #4
     3e2:	f851 0b04 	ldrlt.w	r0, [r1], #4
    strlt   r0, [r2], #4
     3e6:	f842 0b04 	strlt.w	r0, [r2], #4
    blt     .L_loop1
     3ea:	e7f8      	blt.n	3de <Reset_Handler+0xa>
#endif /* __STARTUP_CLEAR_BSS_MULTIPLE || __STARTUP_CLEAR_BSS */

#ifndef __START
#define __START _start
#endif
    bl      __START
     3ec:	f7ff fea4 	bl	138 <_mainCRTStartup>
    .align      2
    .globl      Reset_Handler
    .type       Reset_Handler, %function
Reset_Handler:
#ifndef __NO_SYSTEM_INIT
    ldr     r0, =SystemInit
     3f0:	0000054d 	.word	0x0000054d
 *    __data_start__: VMA of start of the section to copy to
 *    __data_end__: VMA of end of the section to copy to
 *
 *  All addresses must be aligned to 4 bytes boundary.
 */
    ldr     r1, =__etext
     3f4:	00001090 	.word	0x00001090
    ldr     r2, =__data_start__
     3f8:	20000000 	.word	0x20000000
    ldr     r3, =__data_end__
     3fc:	20000078 	.word	0x20000078

00000400 <ACMP0_IRQHandler>:
    .align  1
    .thumb_func
    .weak   Default_Handler
    .type   Default_Handler, %function
Default_Handler:
    b       .
     400:	e7fe      	b.n	400 <ACMP0_IRQHandler>
     402:	bf00      	nop

00000404 <GetProdRev>:
#endif

/* Inline function to get the chip's Production Revision. */
__STATIC_INLINE uint8_t GetProdRev(void)
{
  return ((DEVINFO->PART & _DEVINFO_PART_PROD_REV_MASK)
     404:	4b03      	ldr	r3, [pc, #12]	; (414 <GetProdRev+0x10>)
     406:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
     408:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
                         >> _DEVINFO_PART_PROD_REV_SHIFT);
     40c:	0e1b      	lsrs	r3, r3, #24
#endif

/* Inline function to get the chip's Production Revision. */
__STATIC_INLINE uint8_t GetProdRev(void)
{
  return ((DEVINFO->PART & _DEVINFO_PART_PROD_REV_MASK)
     40e:	b2db      	uxtb	r3, r3
                         >> _DEVINFO_PART_PROD_REV_SHIFT);
}
     410:	4618      	mov	r0, r3
     412:	4770      	bx	lr
     414:	0fe081b0 	.word	0x0fe081b0

00000418 <SystemCoreClockGet>:
 *
 * @return
 *   The current core clock frequency in Hz.
 ******************************************************************************/
uint32_t SystemCoreClockGet(void)
{
     418:	b500      	push	{lr}
     41a:	b083      	sub	sp, #12
  uint32_t ret;

  ret = SystemHFClockGet();
     41c:	f000 f816 	bl	44c <SystemHFClockGet>
     420:	9001      	str	r0, [sp, #4]
  ret >>= (CMU->HFCORECLKDIV & _CMU_HFCORECLKDIV_HFCORECLKDIV_MASK) >>
     422:	4b08      	ldr	r3, [pc, #32]	; (444 <SystemCoreClockGet+0x2c>)
     424:	685b      	ldr	r3, [r3, #4]
     426:	f003 030f 	and.w	r3, r3, #15
     42a:	9a01      	ldr	r2, [sp, #4]
     42c:	fa22 f303 	lsr.w	r3, r2, r3
     430:	9301      	str	r3, [sp, #4]
          _CMU_HFCORECLKDIV_HFCORECLKDIV_SHIFT;

  /* Keep CMSIS variable up-to-date just in case */
  SystemCoreClock = ret;
     432:	4a05      	ldr	r2, [pc, #20]	; (448 <SystemCoreClockGet+0x30>)
     434:	9b01      	ldr	r3, [sp, #4]
     436:	6013      	str	r3, [r2, #0]

  return ret;
     438:	9b01      	ldr	r3, [sp, #4]
}
     43a:	4618      	mov	r0, r3
     43c:	b003      	add	sp, #12
     43e:	f85d fb04 	ldr.w	pc, [sp], #4
     442:	bf00      	nop
     444:	400c8000 	.word	0x400c8000
     448:	20000008 	.word	0x20000008

0000044c <SystemHFClockGet>:
 *
 * @return
 *   The current HFCLK frequency in Hz.
 ******************************************************************************/
uint32_t SystemHFClockGet(void)
{
     44c:	b500      	push	{lr}
     44e:	b083      	sub	sp, #12
  uint32_t ret;

  switch (CMU->STATUS & (CMU_STATUS_HFRCOSEL | CMU_STATUS_HFXOSEL |
     450:	4b33      	ldr	r3, [pc, #204]	; (520 <SystemHFClockGet+0xd4>)
     452:	6adb      	ldr	r3, [r3, #44]	; 0x2c
     454:	f403 5370 	and.w	r3, r3, #15360	; 0x3c00
     458:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
     45c:	d00a      	beq.n	474 <SystemHFClockGet+0x28>
     45e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
     462:	d003      	beq.n	46c <SystemHFClockGet+0x20>
     464:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
     468:	d008      	beq.n	47c <SystemHFClockGet+0x30>
     46a:	e00b      	b.n	484 <SystemHFClockGet+0x38>
                         CMU_STATUS_LFRCOSEL | CMU_STATUS_LFXOSEL))
  {
    case CMU_STATUS_LFXOSEL:
#if (EFM32_LFXO_FREQ > 0)
      ret = SystemLFXOClock;
     46c:	4b2d      	ldr	r3, [pc, #180]	; (524 <SystemHFClockGet+0xd8>)
     46e:	681b      	ldr	r3, [r3, #0]
     470:	9301      	str	r3, [sp, #4]
#else
      /* We should not get here, since core should not be clocked. May */
      /* be caused by a misconfiguration though. */
      ret = 0;
#endif
      break;
     472:	e047      	b.n	504 <SystemHFClockGet+0xb8>

    case CMU_STATUS_LFRCOSEL:
      ret = EFM32_LFRCO_FREQ;
     474:	f44f 4300 	mov.w	r3, #32768	; 0x8000
     478:	9301      	str	r3, [sp, #4]
      break;
     47a:	e043      	b.n	504 <SystemHFClockGet+0xb8>

    case CMU_STATUS_HFXOSEL:
#if (EFM32_HFXO_FREQ > 0)
      ret = SystemHFXOClock;
     47c:	4b2a      	ldr	r3, [pc, #168]	; (528 <SystemHFClockGet+0xdc>)
     47e:	681b      	ldr	r3, [r3, #0]
     480:	9301      	str	r3, [sp, #4]
#else
      /* We should not get here, since core should not be clocked. May */
      /* be caused by a misconfiguration though. */
      ret = 0;
#endif
      break;
     482:	e03f      	b.n	504 <SystemHFClockGet+0xb8>

    default: /* CMU_STATUS_HFRCOSEL */
      switch (CMU->HFRCOCTRL & _CMU_HFRCOCTRL_BAND_MASK)
     484:	4b26      	ldr	r3, [pc, #152]	; (520 <SystemHFClockGet+0xd4>)
     486:	68db      	ldr	r3, [r3, #12]
     488:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
     48c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
     490:	d01b      	beq.n	4ca <SystemHFClockGet+0x7e>
     492:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
     496:	d805      	bhi.n	4a4 <SystemHFClockGet+0x58>
     498:	2b00      	cmp	r3, #0
     49a:	d024      	beq.n	4e6 <SystemHFClockGet+0x9a>
     49c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
     4a0:	d016      	beq.n	4d0 <SystemHFClockGet+0x84>
     4a2:	e02b      	b.n	4fc <SystemHFClockGet+0xb0>
     4a4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
     4a8:	d009      	beq.n	4be <SystemHFClockGet+0x72>
     4aa:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
     4ae:	d003      	beq.n	4b8 <SystemHFClockGet+0x6c>
     4b0:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
     4b4:	d006      	beq.n	4c4 <SystemHFClockGet+0x78>
     4b6:	e021      	b.n	4fc <SystemHFClockGet+0xb0>
      {
      case CMU_HFRCOCTRL_BAND_28MHZ:
        ret = 28000000;
     4b8:	4b1c      	ldr	r3, [pc, #112]	; (52c <SystemHFClockGet+0xe0>)
     4ba:	9301      	str	r3, [sp, #4]
        break;
     4bc:	e021      	b.n	502 <SystemHFClockGet+0xb6>

      case CMU_HFRCOCTRL_BAND_21MHZ:
        ret = 21000000;
     4be:	4b1c      	ldr	r3, [pc, #112]	; (530 <SystemHFClockGet+0xe4>)
     4c0:	9301      	str	r3, [sp, #4]
        break;
     4c2:	e01e      	b.n	502 <SystemHFClockGet+0xb6>

      case CMU_HFRCOCTRL_BAND_14MHZ:
        ret = 14000000;
     4c4:	4b1b      	ldr	r3, [pc, #108]	; (534 <SystemHFClockGet+0xe8>)
     4c6:	9301      	str	r3, [sp, #4]
        break;
     4c8:	e01b      	b.n	502 <SystemHFClockGet+0xb6>

      case CMU_HFRCOCTRL_BAND_11MHZ:
        ret = 11000000;
     4ca:	4b1b      	ldr	r3, [pc, #108]	; (538 <SystemHFClockGet+0xec>)
     4cc:	9301      	str	r3, [sp, #4]
        break;
     4ce:	e018      	b.n	502 <SystemHFClockGet+0xb6>

      case CMU_HFRCOCTRL_BAND_7MHZ:
        if ( GetProdRev() >= 19 )
     4d0:	f7ff ff98 	bl	404 <GetProdRev>
     4d4:	4603      	mov	r3, r0
     4d6:	2b12      	cmp	r3, #18
     4d8:	d902      	bls.n	4e0 <SystemHFClockGet+0x94>
          ret = 6600000;
     4da:	4b18      	ldr	r3, [pc, #96]	; (53c <SystemHFClockGet+0xf0>)
     4dc:	9301      	str	r3, [sp, #4]
        else
          ret = 7000000;
        break;
     4de:	e010      	b.n	502 <SystemHFClockGet+0xb6>

      case CMU_HFRCOCTRL_BAND_7MHZ:
        if ( GetProdRev() >= 19 )
          ret = 6600000;
        else
          ret = 7000000;
     4e0:	4b17      	ldr	r3, [pc, #92]	; (540 <SystemHFClockGet+0xf4>)
     4e2:	9301      	str	r3, [sp, #4]
        break;
     4e4:	e00d      	b.n	502 <SystemHFClockGet+0xb6>

      case CMU_HFRCOCTRL_BAND_1MHZ:
        if ( GetProdRev() >= 19 )
     4e6:	f7ff ff8d 	bl	404 <GetProdRev>
     4ea:	4603      	mov	r3, r0
     4ec:	2b12      	cmp	r3, #18
     4ee:	d902      	bls.n	4f6 <SystemHFClockGet+0xaa>
          ret = 1200000;
     4f0:	4b14      	ldr	r3, [pc, #80]	; (544 <SystemHFClockGet+0xf8>)
     4f2:	9301      	str	r3, [sp, #4]
        else
          ret = 1000000;
        break;
     4f4:	e005      	b.n	502 <SystemHFClockGet+0xb6>

      case CMU_HFRCOCTRL_BAND_1MHZ:
        if ( GetProdRev() >= 19 )
          ret = 1200000;
        else
          ret = 1000000;
     4f6:	4b14      	ldr	r3, [pc, #80]	; (548 <SystemHFClockGet+0xfc>)
     4f8:	9301      	str	r3, [sp, #4]
        break;
     4fa:	e002      	b.n	502 <SystemHFClockGet+0xb6>

      default:
        ret = 0;
     4fc:	2300      	movs	r3, #0
     4fe:	9301      	str	r3, [sp, #4]
        break;
     500:	bf00      	nop
      }
      break;
     502:	bf00      	nop
  }

  return ret / (1U + ((CMU->CTRL & _CMU_CTRL_HFCLKDIV_MASK)
     504:	4b06      	ldr	r3, [pc, #24]	; (520 <SystemHFClockGet+0xd4>)
     506:	681b      	ldr	r3, [r3, #0]
     508:	f403 33e0 	and.w	r3, r3, #114688	; 0x1c000
                      >> _CMU_CTRL_HFCLKDIV_SHIFT));
     50c:	0b9b      	lsrs	r3, r3, #14
        break;
      }
      break;
  }

  return ret / (1U + ((CMU->CTRL & _CMU_CTRL_HFCLKDIV_MASK)
     50e:	3301      	adds	r3, #1
     510:	9a01      	ldr	r2, [sp, #4]
     512:	fbb2 f3f3 	udiv	r3, r2, r3
                      >> _CMU_CTRL_HFCLKDIV_SHIFT));
}
     516:	4618      	mov	r0, r3
     518:	b003      	add	sp, #12
     51a:	f85d fb04 	ldr.w	pc, [sp], #4
     51e:	bf00      	nop
     520:	400c8000 	.word	0x400c8000
     524:	20000004 	.word	0x20000004
     528:	20000000 	.word	0x20000000
     52c:	01ab3f00 	.word	0x01ab3f00
     530:	01406f40 	.word	0x01406f40
     534:	00d59f80 	.word	0x00d59f80
     538:	00a7d8c0 	.word	0x00a7d8c0
     53c:	0064b540 	.word	0x0064b540
     540:	006acfc0 	.word	0x006acfc0
     544:	00124f80 	.word	0x00124f80
     548:	000f4240 	.word	0x000f4240

0000054c <SystemInit>:
 *   and any data has been initialized. For this reason, it cannot do any
 *   initialization of variables etc.
 *****************************************************************************/
void SystemInit(void)
{
}
     54c:	bf00      	nop
     54e:	4770      	bx	lr

00000550 <SystemLFRCOClockGet>:
uint32_t SystemLFRCOClockGet(void)
{
  /* Currently we assume that this frequency is properly tuned during */
  /* manufacturing and is not changed after reset. If future requirements */
  /* for re-tuning by user, we can add support for that. */
  return EFM32_LFRCO_FREQ;
     550:	f44f 4300 	mov.w	r3, #32768	; 0x8000
}
     554:	4618      	mov	r0, r3
     556:	4770      	bx	lr

00000558 <SystemULFRCOClockGet>:
 *   ULFRCO frequency in Hz.
 *****************************************************************************/
uint32_t SystemULFRCOClockGet(void)
{
  /* The ULFRCO frequency is not tuned, and can be very inaccurate */
  return EFM32_ULFRCO_FREQ;
     558:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
}
     55c:	4618      	mov	r0, r3
     55e:	4770      	bx	lr

00000560 <SystemLFXOClockGet>:
 *****************************************************************************/
uint32_t SystemLFXOClockGet(void)
{
  /* External crystal oscillator present? */
#if (EFM32_LFXO_FREQ > 0)
  return SystemLFXOClock;
     560:	4b01      	ldr	r3, [pc, #4]	; (568 <SystemLFXOClockGet+0x8>)
     562:	681b      	ldr	r3, [r3, #0]
#else
  return 0;
#endif
}
     564:	4618      	mov	r0, r3
     566:	4770      	bx	lr
     568:	20000004 	.word	0x20000004

0000056c <BUS_RegBitWrite>:
 * @param[in] val Value to set bit to, 0 or 1
 ******************************************************************************/
__STATIC_INLINE void BUS_RegBitWrite(volatile uint32_t *addr,
                                     unsigned int bit,
                                     unsigned int val)
{
     56c:	b086      	sub	sp, #24
     56e:	9003      	str	r0, [sp, #12]
     570:	9102      	str	r1, [sp, #8]
     572:	9201      	str	r2, [sp, #4]
#if defined(BITBAND_PER_BASE)
  uint32_t aliasAddr =
    BITBAND_PER_BASE + (((uint32_t)addr - PER_MEM_BASE) * 32) + (bit * 4);
     574:	9b03      	ldr	r3, [sp, #12]
     576:	f103 7304 	add.w	r3, r3, #34603008	; 0x2100000
     57a:	00da      	lsls	r2, r3, #3
     57c:	9b02      	ldr	r3, [sp, #8]
     57e:	4413      	add	r3, r2
__STATIC_INLINE void BUS_RegBitWrite(volatile uint32_t *addr,
                                     unsigned int bit,
                                     unsigned int val)
{
#if defined(BITBAND_PER_BASE)
  uint32_t aliasAddr =
     580:	009b      	lsls	r3, r3, #2
     582:	9305      	str	r3, [sp, #20]
    BITBAND_PER_BASE + (((uint32_t)addr - PER_MEM_BASE) * 32) + (bit * 4);

  *(volatile uint32_t *)aliasAddr = (uint32_t)val;
     584:	9b05      	ldr	r3, [sp, #20]
     586:	9a01      	ldr	r2, [sp, #4]
     588:	601a      	str	r2, [r3, #0]
  uint32_t tmp = *addr;

  /* Make sure val is not more than 1, because we only want to set one bit. */
  *addr = (tmp & ~(1 << bit)) | ((val & 1) << bit);
#endif
}
     58a:	bf00      	nop
     58c:	b006      	add	sp, #24
     58e:	4770      	bx	lr

00000590 <BUS_RegBitRead>:
 * @return
 *     The requested bit shifted to bit position 0 in the return value
 ******************************************************************************/
__STATIC_INLINE unsigned int BUS_RegBitRead(volatile const uint32_t *addr,
                                            unsigned int bit)
{
     590:	b084      	sub	sp, #16
     592:	9001      	str	r0, [sp, #4]
     594:	9100      	str	r1, [sp, #0]
#if defined(BITBAND_PER_BASE)
  uint32_t aliasAddr =
    BITBAND_PER_BASE + (((uint32_t)addr - PER_MEM_BASE) * 32) + (bit * 4);
     596:	9b01      	ldr	r3, [sp, #4]
     598:	f103 7304 	add.w	r3, r3, #34603008	; 0x2100000
     59c:	00da      	lsls	r2, r3, #3
     59e:	9b00      	ldr	r3, [sp, #0]
     5a0:	4413      	add	r3, r2
 ******************************************************************************/
__STATIC_INLINE unsigned int BUS_RegBitRead(volatile const uint32_t *addr,
                                            unsigned int bit)
{
#if defined(BITBAND_PER_BASE)
  uint32_t aliasAddr =
     5a2:	009b      	lsls	r3, r3, #2
     5a4:	9303      	str	r3, [sp, #12]
    BITBAND_PER_BASE + (((uint32_t)addr - PER_MEM_BASE) * 32) + (bit * 4);

  return *(volatile uint32_t *)aliasAddr;
     5a6:	9b03      	ldr	r3, [sp, #12]
     5a8:	681b      	ldr	r3, [r3, #0]
#else
  return ((*addr) >> bit) & 1;
#endif
}
     5aa:	4618      	mov	r0, r3
     5ac:	b004      	add	sp, #16
     5ae:	4770      	bx	lr

000005b0 <CMU_DivToLog2>:
 *
 * @return
 *   Logarithm of 2, as used by fixed prescalers.
 ******************************************************************************/
__STATIC_INLINE uint32_t CMU_DivToLog2(CMU_ClkDiv_TypeDef div)
{
     5b0:	b084      	sub	sp, #16
     5b2:	9001      	str	r0, [sp, #4]
  uint32_t log2;

  /* Fixed 2^n prescalers take argument of 32768 or less. */
  EFM_ASSERT((div > 0U) && (div <= 32768U));
     5b4:	9b01      	ldr	r3, [sp, #4]
     5b6:	2b00      	cmp	r3, #0
     5b8:	d003      	beq.n	5c2 <CMU_DivToLog2+0x12>
     5ba:	9b01      	ldr	r3, [sp, #4]
     5bc:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
     5c0:	bf00      	nop

  /* Count leading zeroes and "reverse" result */
  log2 = (31U - __CLZ(div));
     5c2:	9b01      	ldr	r3, [sp, #4]
     5c4:	fab3 f383 	clz	r3, r3
     5c8:	f1c3 031f 	rsb	r3, r3, #31
     5cc:	9303      	str	r3, [sp, #12]

  return log2;
     5ce:	9b03      	ldr	r3, [sp, #12]
}
     5d0:	4618      	mov	r0, r3
     5d2:	b004      	add	sp, #16
     5d4:	4770      	bx	lr
     5d6:	bf00      	nop

000005d8 <SYSTEM_GetProdRev>:
 * @return
 *   Production revision for this part.
 ******************************************************************************/
__STATIC_INLINE uint8_t SYSTEM_GetProdRev(void)
{
  return (DEVINFO->PART & _DEVINFO_PART_PROD_REV_MASK)
     5d8:	4b03      	ldr	r3, [pc, #12]	; (5e8 <SYSTEM_GetProdRev+0x10>)
     5da:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
     5dc:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
         >> _DEVINFO_PART_PROD_REV_SHIFT;
     5e0:	0e1b      	lsrs	r3, r3, #24
 * @return
 *   Production revision for this part.
 ******************************************************************************/
__STATIC_INLINE uint8_t SYSTEM_GetProdRev(void)
{
  return (DEVINFO->PART & _DEVINFO_PART_PROD_REV_MASK)
     5e2:	b2db      	uxtb	r3, r3
         >> _DEVINFO_PART_PROD_REV_SHIFT;
}
     5e4:	4618      	mov	r0, r3
     5e6:	4770      	bx	lr
     5e8:	0fe081b0 	.word	0x0fe081b0

000005ec <SYSTEM_GetFamily>:
 *   The family identifier of the MCU.
 ******************************************************************************/
__STATIC_INLINE SYSTEM_PartFamily_TypeDef SYSTEM_GetFamily(void)
{
  return (SYSTEM_PartFamily_TypeDef)
         ((DEVINFO->PART & _DEVINFO_PART_DEVICE_FAMILY_MASK)
     5ec:	4b03      	ldr	r3, [pc, #12]	; (5fc <SYSTEM_GetFamily+0x10>)
     5ee:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
     5f0:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
          >> _DEVINFO_PART_DEVICE_FAMILY_SHIFT);
     5f4:	0c1b      	lsrs	r3, r3, #16
 * @return
 *   The family identifier of the MCU.
 ******************************************************************************/
__STATIC_INLINE SYSTEM_PartFamily_TypeDef SYSTEM_GetFamily(void)
{
  return (SYSTEM_PartFamily_TypeDef)
     5f6:	b2db      	uxtb	r3, r3
         ((DEVINFO->PART & _DEVINFO_PART_DEVICE_FAMILY_MASK)
          >> _DEVINFO_PART_DEVICE_FAMILY_SHIFT);
}
     5f8:	4618      	mov	r0, r3
     5fa:	4770      	bx	lr
     5fc:	0fe081b0 	.word	0x0fe081b0

00000600 <maxFreqHfle>:
/***************************************************************************//**
 * @brief
 *   Return max allowed frequency for low energy peripherals.
 ******************************************************************************/
static uint32_t maxFreqHfle(void)
{
     600:	b500      	push	{lr}
     602:	b083      	sub	sp, #12
  uint16_t majorMinorRev;

  switch (SYSTEM_GetFamily()) {
     604:	f7ff fff2 	bl	5ec <SYSTEM_GetFamily>
     608:	4603      	mov	r3, r0
     60a:	2b4a      	cmp	r3, #74	; 0x4a
     60c:	d004      	beq.n	618 <maxFreqHfle+0x18>
     60e:	2b79      	cmp	r3, #121	; 0x79
     610:	d002      	beq.n	618 <maxFreqHfle+0x18>
     612:	2b48      	cmp	r3, #72	; 0x48
     614:	d027      	beq.n	666 <maxFreqHfle+0x66>
     616:	e028      	b.n	66a <maxFreqHfle+0x6a>
    case systemPartFamilyEfm32Leopard:
    case systemPartFamilyEzr32Leopard:
      /* CHIP MAJOR bit [5:0] */
      majorMinorRev = (((ROMTABLE->PID0 & _ROMTABLE_PID0_REVMAJOR_MASK)
     618:	4b16      	ldr	r3, [pc, #88]	; (674 <maxFreqHfle+0x74>)
     61a:	691b      	ldr	r3, [r3, #16]
     61c:	b29b      	uxth	r3, r3
     61e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
     622:	b29b      	uxth	r3, r3
     624:	021b      	lsls	r3, r3, #8
     626:	f8ad 3006 	strh.w	r3, [sp, #6]
                        >> _ROMTABLE_PID0_REVMAJOR_SHIFT) << 8);
      /* CHIP MINOR bit [7:4] */
      majorMinorRev |= (((ROMTABLE->PID2 & _ROMTABLE_PID2_REVMINORMSB_MASK)
     62a:	4b12      	ldr	r3, [pc, #72]	; (674 <maxFreqHfle+0x74>)
     62c:	699b      	ldr	r3, [r3, #24]
                         >> _ROMTABLE_PID2_REVMINORMSB_SHIFT) << 4);
     62e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    case systemPartFamilyEzr32Leopard:
      /* CHIP MAJOR bit [5:0] */
      majorMinorRev = (((ROMTABLE->PID0 & _ROMTABLE_PID0_REVMAJOR_MASK)
                        >> _ROMTABLE_PID0_REVMAJOR_SHIFT) << 8);
      /* CHIP MINOR bit [7:4] */
      majorMinorRev |= (((ROMTABLE->PID2 & _ROMTABLE_PID2_REVMINORMSB_MASK)
     632:	b29a      	uxth	r2, r3
     634:	f8bd 3006 	ldrh.w	r3, [sp, #6]
     638:	4313      	orrs	r3, r2
     63a:	f8ad 3006 	strh.w	r3, [sp, #6]
                         >> _ROMTABLE_PID2_REVMINORMSB_SHIFT) << 4);
      /* CHIP MINOR bit [3:0] */
      majorMinorRev |=  ((ROMTABLE->PID3 & _ROMTABLE_PID3_REVMINORLSB_MASK)
     63e:	4b0d      	ldr	r3, [pc, #52]	; (674 <maxFreqHfle+0x74>)
     640:	69db      	ldr	r3, [r3, #28]
     642:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
                         >> _ROMTABLE_PID3_REVMINORLSB_SHIFT);
     646:	091b      	lsrs	r3, r3, #4
                        >> _ROMTABLE_PID0_REVMAJOR_SHIFT) << 8);
      /* CHIP MINOR bit [7:4] */
      majorMinorRev |= (((ROMTABLE->PID2 & _ROMTABLE_PID2_REVMINORMSB_MASK)
                         >> _ROMTABLE_PID2_REVMINORMSB_SHIFT) << 4);
      /* CHIP MINOR bit [3:0] */
      majorMinorRev |=  ((ROMTABLE->PID3 & _ROMTABLE_PID3_REVMINORLSB_MASK)
     648:	b29a      	uxth	r2, r3
     64a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
     64e:	4313      	orrs	r3, r2
     650:	f8ad 3006 	strh.w	r3, [sp, #6]
                         >> _ROMTABLE_PID3_REVMINORLSB_SHIFT);

      if (majorMinorRev >= 0x0204) {
     654:	f8bd 3006 	ldrh.w	r3, [sp, #6]
     658:	f5b3 7f01 	cmp.w	r3, #516	; 0x204
     65c:	d301      	bcc.n	662 <maxFreqHfle+0x62>
        return 24000000;
     65e:	4b06      	ldr	r3, [pc, #24]	; (678 <maxFreqHfle+0x78>)
     660:	e004      	b.n	66c <maxFreqHfle+0x6c>
      } else {
        return 32000000;
     662:	4b06      	ldr	r3, [pc, #24]	; (67c <maxFreqHfle+0x7c>)
     664:	e002      	b.n	66c <maxFreqHfle+0x6c>
      }

    case systemPartFamilyEfm32Giant:
      return 32000000;
     666:	4b05      	ldr	r3, [pc, #20]	; (67c <maxFreqHfle+0x7c>)
     668:	e000      	b.n	66c <maxFreqHfle+0x6c>

    default:
      /* Invalid device family. */
      EFM_ASSERT(false);
      return 0;
     66a:	2300      	movs	r3, #0
  }
}
     66c:	4618      	mov	r0, r3
     66e:	b003      	add	sp, #12
     670:	f85d fb04 	ldr.w	pc, [sp], #4
     674:	e00fffd0 	.word	0xe00fffd0
     678:	016e3600 	.word	0x016e3600
     67c:	01e84800 	.word	0x01e84800

00000680 <setHfLeConfig>:
 *
 * @param[in] maxLeFreq
 *   Max LE frequency
 ******************************************************************************/
static void setHfLeConfig(uint32_t hfFreq)
{
     680:	b500      	push	{lr}
     682:	b085      	sub	sp, #20
     684:	9001      	str	r0, [sp, #4]

  /* - Enable HFLE wait-state if to allow access to LE peripherals when HFBUSCLK is
       above maxLeFreq.
     - Set HFLE prescaler. Allowed HFLE clock frequency is maxLeFreq. */

  hfleWs = 1;
     686:	2301      	movs	r3, #1
     688:	9303      	str	r3, [sp, #12]
  if (hfFreq <= CMU_MAX_FREQ_HFLE) {
     68a:	f7ff ffb9 	bl	600 <maxFreqHfle>
     68e:	4602      	mov	r2, r0
     690:	9b01      	ldr	r3, [sp, #4]
     692:	429a      	cmp	r2, r3
     694:	d304      	bcc.n	6a0 <setHfLeConfig+0x20>
    hfleWs = 0;
     696:	2300      	movs	r3, #0
     698:	9303      	str	r3, [sp, #12]
    hflePresc = 0;
     69a:	2300      	movs	r3, #0
     69c:	9302      	str	r3, [sp, #8]
     69e:	e00b      	b.n	6b8 <setHfLeConfig+0x38>
  } else if (hfFreq <= (2 * CMU_MAX_FREQ_HFLE)) {
     6a0:	f7ff ffae 	bl	600 <maxFreqHfle>
     6a4:	4603      	mov	r3, r0
     6a6:	005a      	lsls	r2, r3, #1
     6a8:	9b01      	ldr	r3, [sp, #4]
     6aa:	429a      	cmp	r2, r3
     6ac:	d302      	bcc.n	6b4 <setHfLeConfig+0x34>
    hflePresc = 1;
     6ae:	2301      	movs	r3, #1
     6b0:	9302      	str	r3, [sp, #8]
     6b2:	e001      	b.n	6b8 <setHfLeConfig+0x38>
  } else {
    hflePresc = 2;
     6b4:	2302      	movs	r3, #2
     6b6:	9302      	str	r3, [sp, #8]
  }
  BUS_RegBitWrite(&CMU->CTRL, _GENERIC_HFLE_WS_SHIFT, hfleWs);
     6b8:	9a03      	ldr	r2, [sp, #12]
     6ba:	211e      	movs	r1, #30
     6bc:	4807      	ldr	r0, [pc, #28]	; (6dc <setHfLeConfig+0x5c>)
     6be:	f7ff ff55 	bl	56c <BUS_RegBitWrite>
  GENERIC_HFLE_PRESC_REG = (GENERIC_HFLE_PRESC_REG & ~_GENERIC_HFLE_PRESC_MASK)
     6c2:	4906      	ldr	r1, [pc, #24]	; (6dc <setHfLeConfig+0x5c>)
     6c4:	4b05      	ldr	r3, [pc, #20]	; (6dc <setHfLeConfig+0x5c>)
     6c6:	685b      	ldr	r3, [r3, #4]
     6c8:	f423 7280 	bic.w	r2, r3, #256	; 0x100
                           | (hflePresc << _GENERIC_HFLE_PRESC_SHIFT);
     6cc:	9b02      	ldr	r3, [sp, #8]
     6ce:	021b      	lsls	r3, r3, #8
     6d0:	4313      	orrs	r3, r2
    hflePresc = 1;
  } else {
    hflePresc = 2;
  }
  BUS_RegBitWrite(&CMU->CTRL, _GENERIC_HFLE_WS_SHIFT, hfleWs);
  GENERIC_HFLE_PRESC_REG = (GENERIC_HFLE_PRESC_REG & ~_GENERIC_HFLE_PRESC_MASK)
     6d2:	604b      	str	r3, [r1, #4]
                           | (hflePresc << _GENERIC_HFLE_PRESC_SHIFT);
}
     6d4:	bf00      	nop
     6d6:	b005      	add	sp, #20
     6d8:	f85d fb04 	ldr.w	pc, [sp], #4
     6dc:	400c8000 	.word	0x400c8000

000006e0 <getHfLeConfig>:
 *
 * @return
 *   Current wait-state configuration.
 ******************************************************************************/
static uint32_t getHfLeConfig(void)
{
     6e0:	b500      	push	{lr}
     6e2:	b083      	sub	sp, #12
  uint32_t ws = BUS_RegBitRead(&CMU->CTRL, _GENERIC_HFLE_WS_SHIFT);
     6e4:	211e      	movs	r1, #30
     6e6:	4804      	ldr	r0, [pc, #16]	; (6f8 <getHfLeConfig+0x18>)
     6e8:	f7ff ff52 	bl	590 <BUS_RegBitRead>
     6ec:	9001      	str	r0, [sp, #4]
  return ws;
     6ee:	9b01      	ldr	r3, [sp, #4]
}
     6f0:	4618      	mov	r0, r3
     6f2:	b003      	add	sp, #12
     6f4:	f85d fb04 	ldr.w	pc, [sp], #4
     6f8:	400c8000 	.word	0x400c8000

000006fc <auxClkGet>:
 *
 * @return
 *   AUX Frequency in Hz
 ******************************************************************************/
static uint32_t auxClkGet(void)
{
     6fc:	b500      	push	{lr}
     6fe:	b083      	sub	sp, #12
#if defined(_CMU_AUXHFRCOCTRL_FREQRANGE_MASK)
  ret = auxHfrcoFreq;

#elif defined(_CMU_AUXHFRCOCTRL_BAND_MASK)
  /* All series 0 families except EFM32G */
  switch (CMU->AUXHFRCOCTRL & _CMU_AUXHFRCOCTRL_BAND_MASK) {
     700:	4b21      	ldr	r3, [pc, #132]	; (788 <auxClkGet+0x8c>)
     702:	695b      	ldr	r3, [r3, #20]
     704:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
     708:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
     70c:	d01c      	beq.n	748 <auxClkGet+0x4c>
     70e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
     712:	d805      	bhi.n	720 <auxClkGet+0x24>
     714:	2b00      	cmp	r3, #0
     716:	d025      	beq.n	764 <auxClkGet+0x68>
     718:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
     71c:	d01f      	beq.n	75e <auxClkGet+0x62>
     71e:	e02a      	b.n	776 <auxClkGet+0x7a>
     720:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
     724:	d024      	beq.n	770 <auxClkGet+0x74>
     726:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
     72a:	d01e      	beq.n	76a <auxClkGet+0x6e>
     72c:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
     730:	d121      	bne.n	776 <auxClkGet+0x7a>
    case CMU_AUXHFRCOCTRL_BAND_1MHZ:
      if ( SYSTEM_GetProdRev() >= 19 ) {
     732:	f7ff ff51 	bl	5d8 <SYSTEM_GetProdRev>
     736:	4603      	mov	r3, r0
     738:	2b12      	cmp	r3, #18
     73a:	d902      	bls.n	742 <auxClkGet+0x46>
        ret = 1200000;
     73c:	4b13      	ldr	r3, [pc, #76]	; (78c <auxClkGet+0x90>)
     73e:	9301      	str	r3, [sp, #4]
      } else {
        ret = 1000000;
      }
      break;
     740:	e01c      	b.n	77c <auxClkGet+0x80>
  switch (CMU->AUXHFRCOCTRL & _CMU_AUXHFRCOCTRL_BAND_MASK) {
    case CMU_AUXHFRCOCTRL_BAND_1MHZ:
      if ( SYSTEM_GetProdRev() >= 19 ) {
        ret = 1200000;
      } else {
        ret = 1000000;
     742:	4b13      	ldr	r3, [pc, #76]	; (790 <auxClkGet+0x94>)
     744:	9301      	str	r3, [sp, #4]
      }
      break;
     746:	e019      	b.n	77c <auxClkGet+0x80>

    case CMU_AUXHFRCOCTRL_BAND_7MHZ:
      if ( SYSTEM_GetProdRev() >= 19 ) {
     748:	f7ff ff46 	bl	5d8 <SYSTEM_GetProdRev>
     74c:	4603      	mov	r3, r0
     74e:	2b12      	cmp	r3, #18
     750:	d902      	bls.n	758 <auxClkGet+0x5c>
        ret = 6600000;
     752:	4b10      	ldr	r3, [pc, #64]	; (794 <auxClkGet+0x98>)
     754:	9301      	str	r3, [sp, #4]
      } else {
        ret = 7000000;
      }
      break;
     756:	e011      	b.n	77c <auxClkGet+0x80>

    case CMU_AUXHFRCOCTRL_BAND_7MHZ:
      if ( SYSTEM_GetProdRev() >= 19 ) {
        ret = 6600000;
      } else {
        ret = 7000000;
     758:	4b0f      	ldr	r3, [pc, #60]	; (798 <auxClkGet+0x9c>)
     75a:	9301      	str	r3, [sp, #4]
      }
      break;
     75c:	e00e      	b.n	77c <auxClkGet+0x80>

    case CMU_AUXHFRCOCTRL_BAND_11MHZ:
      ret = 11000000;
     75e:	4b0f      	ldr	r3, [pc, #60]	; (79c <auxClkGet+0xa0>)
     760:	9301      	str	r3, [sp, #4]
      break;
     762:	e00b      	b.n	77c <auxClkGet+0x80>

    case CMU_AUXHFRCOCTRL_BAND_14MHZ:
      ret = 14000000;
     764:	4b0e      	ldr	r3, [pc, #56]	; (7a0 <auxClkGet+0xa4>)
     766:	9301      	str	r3, [sp, #4]
      break;
     768:	e008      	b.n	77c <auxClkGet+0x80>

    case CMU_AUXHFRCOCTRL_BAND_21MHZ:
      ret = 21000000;
     76a:	4b0e      	ldr	r3, [pc, #56]	; (7a4 <auxClkGet+0xa8>)
     76c:	9301      	str	r3, [sp, #4]
      break;
     76e:	e005      	b.n	77c <auxClkGet+0x80>

#if defined(_CMU_AUXHFRCOCTRL_BAND_28MHZ)
    case CMU_AUXHFRCOCTRL_BAND_28MHZ:
      ret = 28000000;
     770:	4b0d      	ldr	r3, [pc, #52]	; (7a8 <auxClkGet+0xac>)
     772:	9301      	str	r3, [sp, #4]
      break;
     774:	e002      	b.n	77c <auxClkGet+0x80>
#endif

    default:
      EFM_ASSERT(0);
      ret = 0;
     776:	2300      	movs	r3, #0
     778:	9301      	str	r3, [sp, #4]
      break;
     77a:	bf00      	nop
  /* Gecko has a fixed 14Mhz AUXHFRCO clock */
  ret = 14000000;

#endif

  return ret;
     77c:	9b01      	ldr	r3, [sp, #4]
}
     77e:	4618      	mov	r0, r3
     780:	b003      	add	sp, #12
     782:	f85d fb04 	ldr.w	pc, [sp], #4
     786:	bf00      	nop
     788:	400c8000 	.word	0x400c8000
     78c:	00124f80 	.word	0x00124f80
     790:	000f4240 	.word	0x000f4240
     794:	0064b540 	.word	0x0064b540
     798:	006acfc0 	.word	0x006acfc0
     79c:	00a7d8c0 	.word	0x00a7d8c0
     7a0:	00d59f80 	.word	0x00d59f80
     7a4:	01406f40 	.word	0x01406f40
     7a8:	01ab3f00 	.word	0x01ab3f00

000007ac <dbgClkGet>:
 *
 * @return
 *   Debug Trace frequency in Hz
 ******************************************************************************/
static uint32_t dbgClkGet(void)
{
     7ac:	b500      	push	{lr}
     7ae:	b083      	sub	sp, #12
  uint32_t ret;
  CMU_Select_TypeDef clk;

  /* Get selected clock source */
  clk = CMU_ClockSelectGet(cmuClock_DBG);
     7b0:	480d      	ldr	r0, [pc, #52]	; (7e8 <dbgClkGet+0x3c>)
     7b2:	f000 fa1b 	bl	bec <CMU_ClockSelectGet>
     7b6:	4603      	mov	r3, r0
     7b8:	f88d 3003 	strb.w	r3, [sp, #3]

  switch (clk) {
     7bc:	f89d 3003 	ldrb.w	r3, [sp, #3]
     7c0:	2b07      	cmp	r3, #7
     7c2:	d005      	beq.n	7d0 <dbgClkGet+0x24>
     7c4:	2b09      	cmp	r3, #9
     7c6:	d107      	bne.n	7d8 <dbgClkGet+0x2c>
    case cmuSelect_HFCLK:
      ret = SystemHFClockGet();
     7c8:	f7ff fe40 	bl	44c <SystemHFClockGet>
     7cc:	9001      	str	r0, [sp, #4]
      break;
     7ce:	e006      	b.n	7de <dbgClkGet+0x32>

    case cmuSelect_AUXHFRCO:
      ret = auxClkGet();
     7d0:	f7ff ff94 	bl	6fc <auxClkGet>
     7d4:	9001      	str	r0, [sp, #4]
      break;
     7d6:	e002      	b.n	7de <dbgClkGet+0x32>

    default:
      EFM_ASSERT(0);
      ret = 0;
     7d8:	2300      	movs	r3, #0
     7da:	9301      	str	r3, [sp, #4]
      break;
     7dc:	bf00      	nop
  }
  return ret;
     7de:	9b01      	ldr	r3, [sp, #4]
}
     7e0:	4618      	mov	r0, r3
     7e2:	b003      	add	sp, #12
     7e4:	f85d fb04 	ldr.w	pc, [sp], #4
     7e8:	000c0006 	.word	0x000c0006

000007ec <lfClkGet>:
 * @return
 *   The LFnCLK frequency in Hz. If no LFnCLK is selected (disabled), 0 is
 *   returned.
 ******************************************************************************/
static uint32_t lfClkGet(CMU_Clock_TypeDef lfClkBranch)
{
     7ec:	b510      	push	{r4, lr}
     7ee:	b084      	sub	sp, #16
     7f0:	9001      	str	r0, [sp, #4]
  uint32_t sel;
  uint32_t ret = 0;
     7f2:	2300      	movs	r3, #0
     7f4:	9302      	str	r3, [sp, #8]

  switch (lfClkBranch) {
     7f6:	9b01      	ldr	r3, [sp, #4]
     7f8:	4a32      	ldr	r2, [pc, #200]	; (8c4 <lfClkGet+0xd8>)
     7fa:	4293      	cmp	r3, r2
     7fc:	d003      	beq.n	806 <lfClkGet+0x1a>
     7fe:	4a32      	ldr	r2, [pc, #200]	; (8c8 <lfClkGet+0xdc>)
     800:	4293      	cmp	r3, r2
     802:	d000      	beq.n	806 <lfClkGet+0x1a>
#endif
      break;

    default:
      EFM_ASSERT(0);
      break;
     804:	e000      	b.n	808 <lfClkGet+0x1c>
    case cmuClock_LFC:
#endif
#if defined(_CMU_LFECLKSEL_MASK)
    case cmuClock_LFE:
#endif
      break;
     806:	bf00      	nop
    default:
      EFM_ASSERT(0);
      break;
  }

  sel = CMU_ClockSelectGet(lfClkBranch);
     808:	9801      	ldr	r0, [sp, #4]
     80a:	f000 f9ef 	bl	bec <CMU_ClockSelectGet>
     80e:	4603      	mov	r3, r0
     810:	9303      	str	r3, [sp, #12]

  /* Get clock select field */
  switch (lfClkBranch) {
     812:	9b01      	ldr	r3, [sp, #4]
     814:	4a2b      	ldr	r2, [pc, #172]	; (8c4 <lfClkGet+0xd8>)
     816:	4293      	cmp	r3, r2
     818:	d003      	beq.n	822 <lfClkGet+0x36>
     81a:	4a2b      	ldr	r2, [pc, #172]	; (8c8 <lfClkGet+0xdc>)
     81c:	4293      	cmp	r3, r2
     81e:	d006      	beq.n	82e <lfClkGet+0x42>
      break;
#endif

    default:
      EFM_ASSERT(0);
      break;
     820:	e00c      	b.n	83c <lfClkGet+0x50>

  /* Get clock select field */
  switch (lfClkBranch) {
    case cmuClock_LFA:
#if defined(_CMU_LFCLKSEL_MASK)
      sel = (CMU->LFCLKSEL & _CMU_LFCLKSEL_LFA_MASK) >> _CMU_LFCLKSEL_LFA_SHIFT;
     822:	4b2a      	ldr	r3, [pc, #168]	; (8cc <lfClkGet+0xe0>)
     824:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     826:	f003 0303 	and.w	r3, r3, #3
     82a:	9303      	str	r3, [sp, #12]
#elif defined(_CMU_LFACLKSEL_MASK)
      sel = (CMU->LFACLKSEL & _CMU_LFACLKSEL_LFA_MASK) >> _CMU_LFACLKSEL_LFA_SHIFT;
#else
      EFM_ASSERT(0);
#endif
      break;
     82c:	e006      	b.n	83c <lfClkGet+0x50>

    case cmuClock_LFB:
#if defined(_CMU_LFCLKSEL_MASK)
      sel = (CMU->LFCLKSEL & _CMU_LFCLKSEL_LFB_MASK) >> _CMU_LFCLKSEL_LFB_SHIFT;
     82e:	4b27      	ldr	r3, [pc, #156]	; (8cc <lfClkGet+0xe0>)
     830:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     832:	f003 030c 	and.w	r3, r3, #12
     836:	089b      	lsrs	r3, r3, #2
     838:	9303      	str	r3, [sp, #12]
#elif defined(_CMU_LFBCLKSEL_MASK)
      sel = (CMU->LFBCLKSEL & _CMU_LFBCLKSEL_LFB_MASK) >> _CMU_LFBCLKSEL_LFB_SHIFT;
#else
      EFM_ASSERT(0);
#endif
      break;
     83a:	bf00      	nop
      break;
  }

  /* Get clock frequency */
#if defined(_CMU_LFCLKSEL_MASK)
  switch (sel) {
     83c:	9b03      	ldr	r3, [sp, #12]
     83e:	2b03      	cmp	r3, #3
     840:	d838      	bhi.n	8b4 <lfClkGet+0xc8>
     842:	a201      	add	r2, pc, #4	; (adr r2, 848 <lfClkGet+0x5c>)
     844:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     848:	0000087f 	.word	0x0000087f
     84c:	00000859 	.word	0x00000859
     850:	00000861 	.word	0x00000861
     854:	00000869 	.word	0x00000869
    case _CMU_LFCLKSEL_LFA_LFRCO:
      ret = SystemLFRCOClockGet();
     858:	f7ff fe7a 	bl	550 <SystemLFRCOClockGet>
     85c:	9002      	str	r0, [sp, #8]
      break;
     85e:	e02d      	b.n	8bc <lfClkGet+0xd0>

    case _CMU_LFCLKSEL_LFA_LFXO:
      ret = SystemLFXOClockGet();
     860:	f7ff fe7e 	bl	560 <SystemLFXOClockGet>
     864:	9002      	str	r0, [sp, #8]
      break;
     866:	e029      	b.n	8bc <lfClkGet+0xd0>
#if defined(_CMU_LFCLKSEL_LFA_HFCORECLKLEDIV2)
    case _CMU_LFCLKSEL_LFA_HFCORECLKLEDIV2:
#if defined(CMU_MAX_FREQ_HFLE)
      /* HFLE bit is or'ed by hardware with HFCORECLKLEDIV to reduce the
       * frequency of CMU_HFCORECLKLEDIV2. */
      ret = SystemCoreClockGet() / (1U << (getHfLeConfig() + 1));
     868:	f7ff fdd6 	bl	418 <SystemCoreClockGet>
     86c:	4604      	mov	r4, r0
     86e:	f7ff ff37 	bl	6e0 <getHfLeConfig>
     872:	4603      	mov	r3, r0
     874:	3301      	adds	r3, #1
     876:	fa24 f303 	lsr.w	r3, r4, r3
     87a:	9302      	str	r3, [sp, #8]
#else
      ret = SystemCoreClockGet() / 2U;
#endif
      break;
     87c:	e01e      	b.n	8bc <lfClkGet+0xd0>
#endif

    case _CMU_LFCLKSEL_LFA_DISABLED:
      ret = 0;
     87e:	2300      	movs	r3, #0
     880:	9302      	str	r3, [sp, #8]
#if defined(CMU_LFCLKSEL_LFAE)
      /* Check LF Extended bit setting for LFA or LFB ULFRCO clock */
      if ((lfClkBranch == cmuClock_LFA) || (lfClkBranch == cmuClock_LFB)) {
     882:	9b01      	ldr	r3, [sp, #4]
     884:	4a0f      	ldr	r2, [pc, #60]	; (8c4 <lfClkGet+0xd8>)
     886:	4293      	cmp	r3, r2
     888:	d003      	beq.n	892 <lfClkGet+0xa6>
     88a:	9b01      	ldr	r3, [sp, #4]
     88c:	4a0e      	ldr	r2, [pc, #56]	; (8c8 <lfClkGet+0xdc>)
     88e:	4293      	cmp	r3, r2
     890:	d113      	bne.n	8ba <lfClkGet+0xce>
        if (CMU->LFCLKSEL >> (lfClkBranch == cmuClock_LFA
     892:	4b0e      	ldr	r3, [pc, #56]	; (8cc <lfClkGet+0xe0>)
     894:	6a9a      	ldr	r2, [r3, #40]	; 0x28
                              ? _CMU_LFCLKSEL_LFAE_SHIFT
                              : _CMU_LFCLKSEL_LFBE_SHIFT)) {
     896:	9b01      	ldr	r3, [sp, #4]
     898:	490a      	ldr	r1, [pc, #40]	; (8c4 <lfClkGet+0xd8>)
     89a:	428b      	cmp	r3, r1
     89c:	d101      	bne.n	8a2 <lfClkGet+0xb6>
     89e:	2310      	movs	r3, #16
     8a0:	e000      	b.n	8a4 <lfClkGet+0xb8>
     8a2:	2314      	movs	r3, #20
    case _CMU_LFCLKSEL_LFA_DISABLED:
      ret = 0;
#if defined(CMU_LFCLKSEL_LFAE)
      /* Check LF Extended bit setting for LFA or LFB ULFRCO clock */
      if ((lfClkBranch == cmuClock_LFA) || (lfClkBranch == cmuClock_LFB)) {
        if (CMU->LFCLKSEL >> (lfClkBranch == cmuClock_LFA
     8a4:	fa22 f303 	lsr.w	r3, r2, r3
     8a8:	2b00      	cmp	r3, #0
     8aa:	d006      	beq.n	8ba <lfClkGet+0xce>
                              ? _CMU_LFCLKSEL_LFAE_SHIFT
                              : _CMU_LFCLKSEL_LFBE_SHIFT)) {
          ret = SystemULFRCOClockGet();
     8ac:	f7ff fe54 	bl	558 <SystemULFRCOClockGet>
     8b0:	9002      	str	r0, [sp, #8]
        }
      }
#endif
      break;
     8b2:	e002      	b.n	8ba <lfClkGet+0xce>

    default:
      EFM_ASSERT(0);
      ret = 0U;
     8b4:	2300      	movs	r3, #0
     8b6:	9302      	str	r3, [sp, #8]
      break;
     8b8:	e000      	b.n	8bc <lfClkGet+0xd0>
                              : _CMU_LFCLKSEL_LFBE_SHIFT)) {
          ret = SystemULFRCOClockGet();
        }
      }
#endif
      break;
     8ba:	bf00      	nop
      ret = 0;
      break;
  }
#endif

  return ret;
     8bc:	9b02      	ldr	r3, [sp, #8]
}
     8be:	4618      	mov	r0, r3
     8c0:	b004      	add	sp, #16
     8c2:	bd10      	pop	{r4, pc}
     8c4:	001a0002 	.word	0x001a0002
     8c8:	001c0003 	.word	0x001c0003
     8cc:	400c8000 	.word	0x400c8000

000008d0 <syncReg>:
 * @param[in] mask
 *   Bitmask corresponding to SYNCBUSY register defined bits, indicating
 *   registers that must complete any ongoing synchronization.
 ******************************************************************************/
__STATIC_INLINE void syncReg(uint32_t mask)
{
     8d0:	b082      	sub	sp, #8
     8d2:	9001      	str	r0, [sp, #4]
  /* Avoid deadlock if modifying the same register twice when freeze mode is */
  /* activated. */
  if (CMU->FREEZE & CMU_FREEZE_REGFREEZE) {
     8d4:	4b08      	ldr	r3, [pc, #32]	; (8f8 <syncReg+0x28>)
     8d6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
     8d8:	f003 0301 	and.w	r3, r3, #1
     8dc:	2b00      	cmp	r3, #0
     8de:	d107      	bne.n	8f0 <syncReg+0x20>
    return;
  }

  /* Wait for any pending previous write operation to have been completed */
  /* in low frequency domain */
  while (CMU->SYNCBUSY & mask) {
     8e0:	bf00      	nop
     8e2:	4b05      	ldr	r3, [pc, #20]	; (8f8 <syncReg+0x28>)
     8e4:	6d1a      	ldr	r2, [r3, #80]	; 0x50
     8e6:	9b01      	ldr	r3, [sp, #4]
     8e8:	4013      	ands	r3, r2
     8ea:	2b00      	cmp	r3, #0
     8ec:	d1f9      	bne.n	8e2 <syncReg+0x12>
     8ee:	e000      	b.n	8f2 <syncReg+0x22>
__STATIC_INLINE void syncReg(uint32_t mask)
{
  /* Avoid deadlock if modifying the same register twice when freeze mode is */
  /* activated. */
  if (CMU->FREEZE & CMU_FREEZE_REGFREEZE) {
    return;
     8f0:	bf00      	nop

  /* Wait for any pending previous write operation to have been completed */
  /* in low frequency domain */
  while (CMU->SYNCBUSY & mask) {
  }
}
     8f2:	b002      	add	sp, #8
     8f4:	4770      	bx	lr
     8f6:	bf00      	nop
     8f8:	400c8000 	.word	0x400c8000

000008fc <usbCClkGet>:
 *
 * @return
 *   USBC frequency in Hz
 ******************************************************************************/
static uint32_t usbCClkGet(void)
{
     8fc:	b500      	push	{lr}
     8fe:	b083      	sub	sp, #12
  uint32_t ret;
  CMU_Select_TypeDef clk;

  /* Get selected clock source */
  clk = CMU_ClockSelectGet(cmuClock_USBC);
     900:	4810      	ldr	r0, [pc, #64]	; (944 <usbCClkGet+0x48>)
     902:	f000 f973 	bl	bec <CMU_ClockSelectGet>
     906:	4603      	mov	r3, r0
     908:	f88d 3003 	strb.w	r3, [sp, #3]

  switch (clk) {
     90c:	f89d 3003 	ldrb.w	r3, [sp, #3]
     910:	2b03      	cmp	r3, #3
     912:	d007      	beq.n	924 <usbCClkGet+0x28>
     914:	2b09      	cmp	r3, #9
     916:	d009      	beq.n	92c <usbCClkGet+0x30>
     918:	2b02      	cmp	r3, #2
     91a:	d10b      	bne.n	934 <usbCClkGet+0x38>
    case cmuSelect_LFXO:
      ret = SystemLFXOClockGet();
     91c:	f7ff fe20 	bl	560 <SystemLFXOClockGet>
     920:	9001      	str	r0, [sp, #4]
      break;
     922:	e00a      	b.n	93a <usbCClkGet+0x3e>
    case cmuSelect_LFRCO:
      ret = SystemLFRCOClockGet();
     924:	f7ff fe14 	bl	550 <SystemLFRCOClockGet>
     928:	9001      	str	r0, [sp, #4]
      break;
     92a:	e006      	b.n	93a <usbCClkGet+0x3e>
    case cmuSelect_USHFRCO:
      ret = ushfrcoFreq;
      break;
#endif
    case cmuSelect_HFCLK:
      ret = SystemHFClockGet();
     92c:	f7ff fd8e 	bl	44c <SystemHFClockGet>
     930:	9001      	str	r0, [sp, #4]
      break;
     932:	e002      	b.n	93a <usbCClkGet+0x3e>
    default:
      /* Clock is not enabled */
      ret = 0;
     934:	2300      	movs	r3, #0
     936:	9301      	str	r3, [sp, #4]
      break;
     938:	bf00      	nop
  }
  return ret;
     93a:	9b01      	ldr	r3, [sp, #4]
}
     93c:	4618      	mov	r0, r3
     93e:	b003      	add	sp, #12
     940:	f85d fb04 	ldr.w	pc, [sp], #4
     944:	00222307 	.word	0x00222307

00000948 <CMU_ClockEnable>:
 * @param[in] enable
 *   @li true - enable specified clock.
 *   @li false - disable specified clock.
 ******************************************************************************/
void CMU_ClockEnable(CMU_Clock_TypeDef clock, bool enable)
{
     948:	b500      	push	{lr}
     94a:	b087      	sub	sp, #28
     94c:	9001      	str	r0, [sp, #4]
     94e:	460b      	mov	r3, r1
     950:	f88d 3003 	strb.w	r3, [sp, #3]
  volatile uint32_t *reg;
  uint32_t          bit;
  uint32_t          sync = 0;
     954:	2300      	movs	r3, #0
     956:	9304      	str	r3, [sp, #16]

  /* Identify enable register */
  switch ((clock >> CMU_EN_REG_POS) & CMU_EN_REG_MASK) {
     958:	9b01      	ldr	r3, [sp, #4]
     95a:	0a1b      	lsrs	r3, r3, #8
     95c:	f003 030f 	and.w	r3, r3, #15
     960:	3b01      	subs	r3, #1
     962:	2b09      	cmp	r3, #9
     964:	d846      	bhi.n	9f4 <CMU_ClockEnable+0xac>
     966:	a201      	add	r2, pc, #4	; (adr r2, 96c <CMU_ClockEnable+0x24>)
     968:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     96c:	000009a9 	.word	0x000009a9
     970:	000009af 	.word	0x000009af
     974:	00000995 	.word	0x00000995
     978:	000009f5 	.word	0x000009f5
     97c:	000009f5 	.word	0x000009f5
     980:	000009b5 	.word	0x000009b5
     984:	000009bf 	.word	0x000009bf
     988:	000009f5 	.word	0x000009f5
     98c:	000009f5 	.word	0x000009f5
     990:	000009c9 	.word	0x000009c9
      break;
#endif

#if defined(_CMU_HFCORECLKEN0_MASK)
    case CMU_HFCORECLKEN0_EN_REG:
      reg = &CMU->HFCORECLKEN0;
     994:	4b19      	ldr	r3, [pc, #100]	; (9fc <CMU_ClockEnable+0xb4>)
     996:	9305      	str	r3, [sp, #20]
#if defined(CMU_MAX_FREQ_HFLE)
      setHfLeConfig(CMU_ClockFreqGet(cmuClock_HFLE));
     998:	4819      	ldr	r0, [pc, #100]	; (a00 <CMU_ClockEnable+0xb8>)
     99a:	f000 f83d 	bl	a18 <CMU_ClockFreqGet>
     99e:	4603      	mov	r3, r0
     9a0:	4618      	mov	r0, r3
     9a2:	f7ff fe6d 	bl	680 <setHfLeConfig>
#endif
      break;
     9a6:	e012      	b.n	9ce <CMU_ClockEnable+0x86>
      break;
#endif

#if defined(_CMU_HFPERCLKDIV_MASK)
    case CMU_HFPERCLKDIV_EN_REG:
      reg = &CMU->HFPERCLKDIV;
     9a8:	4b16      	ldr	r3, [pc, #88]	; (a04 <CMU_ClockEnable+0xbc>)
     9aa:	9305      	str	r3, [sp, #20]
      break;
     9ac:	e00f      	b.n	9ce <CMU_ClockEnable+0x86>
#endif

    case CMU_HFPERCLKEN0_EN_REG:
      reg = &CMU->HFPERCLKEN0;
     9ae:	4b16      	ldr	r3, [pc, #88]	; (a08 <CMU_ClockEnable+0xc0>)
     9b0:	9305      	str	r3, [sp, #20]
      break;
     9b2:	e00c      	b.n	9ce <CMU_ClockEnable+0x86>
      reg = &CMU->HFPERCLKEN1;
      break;
#endif

    case CMU_LFACLKEN0_EN_REG:
      reg  = &CMU->LFACLKEN0;
     9b4:	4b15      	ldr	r3, [pc, #84]	; (a0c <CMU_ClockEnable+0xc4>)
     9b6:	9305      	str	r3, [sp, #20]
      sync = CMU_SYNCBUSY_LFACLKEN0;
     9b8:	2301      	movs	r3, #1
     9ba:	9304      	str	r3, [sp, #16]
      break;
     9bc:	e007      	b.n	9ce <CMU_ClockEnable+0x86>

    case CMU_LFBCLKEN0_EN_REG:
      reg  = &CMU->LFBCLKEN0;
     9be:	4b14      	ldr	r3, [pc, #80]	; (a10 <CMU_ClockEnable+0xc8>)
     9c0:	9305      	str	r3, [sp, #20]
      sync = CMU_SYNCBUSY_LFBCLKEN0;
     9c2:	2310      	movs	r3, #16
     9c4:	9304      	str	r3, [sp, #16]
      break;
     9c6:	e002      	b.n	9ce <CMU_ClockEnable+0x86>
      reg = &CMU->USBCTRL;
      break;
#endif

    case CMU_PCNT_EN_REG:
      reg = &CMU->PCNTCTRL;
     9c8:	4b12      	ldr	r3, [pc, #72]	; (a14 <CMU_ClockEnable+0xcc>)
     9ca:	9305      	str	r3, [sp, #20]
      break;
     9cc:	bf00      	nop
      EFM_ASSERT(0);
      return;
  }

  /* Get bit position used to enable/disable */
  bit = (clock >> CMU_EN_BIT_POS) & CMU_EN_BIT_MASK;
     9ce:	9b01      	ldr	r3, [sp, #4]
     9d0:	0b1b      	lsrs	r3, r3, #12
     9d2:	f003 031f 	and.w	r3, r3, #31
     9d6:	9303      	str	r3, [sp, #12]

  /* LF synchronization required? */
  if (sync) {
     9d8:	9b04      	ldr	r3, [sp, #16]
     9da:	2b00      	cmp	r3, #0
     9dc:	d002      	beq.n	9e4 <CMU_ClockEnable+0x9c>
    syncReg(sync);
     9de:	9804      	ldr	r0, [sp, #16]
     9e0:	f7ff ff76 	bl	8d0 <syncReg>
  }

  /* Set/clear bit as requested */
  BUS_RegBitWrite(reg, bit, enable);
     9e4:	f89d 3003 	ldrb.w	r3, [sp, #3]
     9e8:	461a      	mov	r2, r3
     9ea:	9903      	ldr	r1, [sp, #12]
     9ec:	9805      	ldr	r0, [sp, #20]
     9ee:	f7ff fdbd 	bl	56c <BUS_RegBitWrite>
     9f2:	e000      	b.n	9f6 <CMU_ClockEnable+0xae>
      reg = &CMU->PCNTCTRL;
      break;

    default: /* Cannot enable/disable clock point */
      EFM_ASSERT(0);
      return;
     9f4:	bf00      	nop
    syncReg(sync);
  }

  /* Set/clear bit as requested */
  BUS_RegBitWrite(reg, bit, enable);
}
     9f6:	b007      	add	sp, #28
     9f8:	f85d fb04 	ldr.w	pc, [sp], #4
     9fc:	400c8040 	.word	0x400c8040
     a00:	00024300 	.word	0x00024300
     a04:	400c8008 	.word	0x400c8008
     a08:	400c8044 	.word	0x400c8044
     a0c:	400c8058 	.word	0x400c8058
     a10:	400c8060 	.word	0x400c8060
     a14:	400c8078 	.word	0x400c8078

00000a18 <CMU_ClockFreqGet>:
 *
 * @return
 *   The current frequency in Hz.
 ******************************************************************************/
uint32_t CMU_ClockFreqGet(CMU_Clock_TypeDef clock)
{
     a18:	b510      	push	{r4, lr}
     a1a:	b084      	sub	sp, #16
     a1c:	9001      	str	r0, [sp, #4]
  uint32_t ret;

  switch (clock & (CMU_CLK_BRANCH_MASK << CMU_CLK_BRANCH_POS)) {
     a1e:	9b01      	ldr	r3, [sp, #4]
     a20:	f403 1378 	and.w	r3, r3, #4063232	; 0x3e0000
     a24:	f5b3 1fb0 	cmp.w	r3, #1441792	; 0x160000
     a28:	f000 80ab 	beq.w	b82 <CMU_ClockFreqGet+0x16a>
     a2c:	f5b3 1fb0 	cmp.w	r3, #1441792	; 0x160000
     a30:	d81a      	bhi.n	a68 <CMU_ClockFreqGet+0x50>
     a32:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
     a36:	f000 80bf 	beq.w	bb8 <CMU_ClockFreqGet+0x1a0>
     a3a:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
     a3e:	d808      	bhi.n	a52 <CMU_ClockFreqGet+0x3a>
     a40:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
     a44:	d03c      	beq.n	ac0 <CMU_ClockFreqGet+0xa8>
     a46:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
     a4a:	d02d      	beq.n	aa8 <CMU_ClockFreqGet+0x90>
     a4c:	2b00      	cmp	r3, #0
     a4e:	d027      	beq.n	aa0 <CMU_ClockFreqGet+0x88>
     a50:	e0be      	b.n	bd0 <CMU_ClockFreqGet+0x1b8>
     a52:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
     a56:	d03c      	beq.n	ad2 <CMU_ClockFreqGet+0xba>
     a58:	f5b3 1fa0 	cmp.w	r3, #1310720	; 0x140000
     a5c:	d047      	beq.n	aee <CMU_ClockFreqGet+0xd6>
     a5e:	f5b3 2f60 	cmp.w	r3, #917504	; 0xe0000
     a62:	f000 80ad 	beq.w	bc0 <CMU_ClockFreqGet+0x1a8>
     a66:	e0b3      	b.n	bd0 <CMU_ClockFreqGet+0x1b8>
     a68:	f5b3 1f08 	cmp.w	r3, #2228224	; 0x220000
     a6c:	f000 80ac 	beq.w	bc8 <CMU_ClockFreqGet+0x1b0>
     a70:	f5b3 1f08 	cmp.w	r3, #2228224	; 0x220000
     a74:	d80a      	bhi.n	a8c <CMU_ClockFreqGet+0x74>
     a76:	f5b3 1fd0 	cmp.w	r3, #1703936	; 0x1a0000
     a7a:	d025      	beq.n	ac8 <CMU_ClockFreqGet+0xb0>
     a7c:	f5b3 1fe0 	cmp.w	r3, #1835008	; 0x1c0000
     a80:	d07a      	beq.n	b78 <CMU_ClockFreqGet+0x160>
     a82:	f5b3 1fc0 	cmp.w	r3, #1572864	; 0x180000
     a86:	f000 8089 	beq.w	b9c <CMU_ClockFreqGet+0x184>
     a8a:	e0a1      	b.n	bd0 <CMU_ClockFreqGet+0x1b8>
     a8c:	f5b3 1f20 	cmp.w	r3, #2621440	; 0x280000
     a90:	d04e      	beq.n	b30 <CMU_ClockFreqGet+0x118>
     a92:	f5b3 1f28 	cmp.w	r3, #2752512	; 0x2a0000
     a96:	d062      	beq.n	b5e <CMU_ClockFreqGet+0x146>
     a98:	f5b3 1f18 	cmp.w	r3, #2490368	; 0x260000
     a9c:	d035      	beq.n	b0a <CMU_ClockFreqGet+0xf2>
     a9e:	e097      	b.n	bd0 <CMU_ClockFreqGet+0x1b8>
    case (CMU_HF_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = SystemHFClockGet();
     aa0:	f7ff fcd4 	bl	44c <SystemHFClockGet>
     aa4:	9003      	str	r0, [sp, #12]
      break;
     aa6:	e096      	b.n	bd6 <CMU_ClockFreqGet+0x1be>

    case (CMU_HFPER_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = SystemHFClockGet();
     aa8:	f7ff fcd0 	bl	44c <SystemHFClockGet>
     aac:	9003      	str	r0, [sp, #12]
      /* Calculate frequency after HFPER divider. */
#if defined(_CMU_HFPERCLKDIV_HFPERCLKDIV_MASK)
      ret >>= (CMU->HFPERCLKDIV & _CMU_HFPERCLKDIV_HFPERCLKDIV_MASK)
     aae:	4b4c      	ldr	r3, [pc, #304]	; (be0 <CMU_ClockFreqGet+0x1c8>)
     ab0:	689b      	ldr	r3, [r3, #8]
              >> _CMU_HFPERCLKDIV_HFPERCLKDIV_SHIFT;
     ab2:	f003 030f 	and.w	r3, r3, #15

    case (CMU_HFPER_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = SystemHFClockGet();
      /* Calculate frequency after HFPER divider. */
#if defined(_CMU_HFPERCLKDIV_HFPERCLKDIV_MASK)
      ret >>= (CMU->HFPERCLKDIV & _CMU_HFPERCLKDIV_HFPERCLKDIV_MASK)
     ab6:	9a03      	ldr	r2, [sp, #12]
     ab8:	fa22 f303 	lsr.w	r3, r2, r3
     abc:	9303      	str	r3, [sp, #12]
#endif
#if defined(_CMU_HFPERPRESC_PRESC_MASK)
      ret /= 1U + ((CMU->HFPERPRESC & _CMU_HFPERPRESC_PRESC_MASK)
                   >> _CMU_HFPERPRESC_PRESC_SHIFT);
#endif
      break;
     abe:	e08a      	b.n	bd6 <CMU_ClockFreqGet+0x1be>
      || defined(DMA_PRESENT) \
      || defined(EBI_PRESENT) \
      || defined(USB_PRESENT)
    case (CMU_HFCORE_CLK_BRANCH << CMU_CLK_BRANCH_POS):
    {
      ret = SystemCoreClockGet();
     ac0:	f7ff fcaa 	bl	418 <SystemCoreClockGet>
     ac4:	9003      	str	r0, [sp, #12]
    } break;
     ac6:	e086      	b.n	bd6 <CMU_ClockFreqGet+0x1be>
#endif
#endif

    case (CMU_LFA_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = lfClkGet(cmuClock_LFA);
     ac8:	4846      	ldr	r0, [pc, #280]	; (be4 <CMU_ClockFreqGet+0x1cc>)
     aca:	f7ff fe8f 	bl	7ec <lfClkGet>
     ace:	9003      	str	r0, [sp, #12]
      break;
     ad0:	e081      	b.n	bd6 <CMU_ClockFreqGet+0x1be>

#if defined(_CMU_LFACLKEN0_RTC_MASK)
    case (CMU_RTC_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = lfClkGet(cmuClock_LFA);
     ad2:	4844      	ldr	r0, [pc, #272]	; (be4 <CMU_ClockFreqGet+0x1cc>)
     ad4:	f7ff fe8a 	bl	7ec <lfClkGet>
     ad8:	9003      	str	r0, [sp, #12]
      ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_RTC_MASK)
     ada:	4b41      	ldr	r3, [pc, #260]	; (be0 <CMU_ClockFreqGet+0x1c8>)
     adc:	6e9b      	ldr	r3, [r3, #104]	; 0x68
     ade:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
              >> _CMU_LFAPRESC0_RTC_SHIFT;
     ae2:	091b      	lsrs	r3, r3, #4
      break;

#if defined(_CMU_LFACLKEN0_RTC_MASK)
    case (CMU_RTC_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = lfClkGet(cmuClock_LFA);
      ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_RTC_MASK)
     ae4:	9a03      	ldr	r2, [sp, #12]
     ae6:	fa22 f303 	lsr.w	r3, r2, r3
     aea:	9303      	str	r3, [sp, #12]
              >> _CMU_LFAPRESC0_RTC_SHIFT;
      break;
     aec:	e073      	b.n	bd6 <CMU_ClockFreqGet+0x1be>
      break;
#endif

#if defined(_CMU_LFACLKEN0_LETIMER0_MASK)
    case (CMU_LETIMER0_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = lfClkGet(cmuClock_LFA);
     aee:	483d      	ldr	r0, [pc, #244]	; (be4 <CMU_ClockFreqGet+0x1cc>)
     af0:	f7ff fe7c 	bl	7ec <lfClkGet>
     af4:	9003      	str	r0, [sp, #12]
#if defined(_SILICON_LABS_32B_SERIES_0)
      ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_LETIMER0_MASK)
     af6:	4b3a      	ldr	r3, [pc, #232]	; (be0 <CMU_ClockFreqGet+0x1c8>)
     af8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
     afa:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
              >> _CMU_LFAPRESC0_LETIMER0_SHIFT;
     afe:	0a1b      	lsrs	r3, r3, #8

#if defined(_CMU_LFACLKEN0_LETIMER0_MASK)
    case (CMU_LETIMER0_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = lfClkGet(cmuClock_LFA);
#if defined(_SILICON_LABS_32B_SERIES_0)
      ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_LETIMER0_MASK)
     b00:	9a03      	ldr	r2, [sp, #12]
     b02:	fa22 f303 	lsr.w	r3, r2, r3
     b06:	9303      	str	r3, [sp, #12]
              >> _CMU_LFAPRESC0_LETIMER0_SHIFT;
#else
      ret /= CMU_Log2ToDiv((CMU->LFAPRESC0 & _CMU_LFAPRESC0_LETIMER0_MASK)
                           >> _CMU_LFAPRESC0_LETIMER0_SHIFT);
#endif
      break;
     b08:	e065      	b.n	bd6 <CMU_ClockFreqGet+0x1be>
#endif

#if defined(_CMU_LFACLKEN0_LCD_MASK)
    case (CMU_LCDPRE_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = lfClkGet(cmuClock_LFA);
     b0a:	4836      	ldr	r0, [pc, #216]	; (be4 <CMU_ClockFreqGet+0x1cc>)
     b0c:	f7ff fe6e 	bl	7ec <lfClkGet>
     b10:	9003      	str	r0, [sp, #12]
#if defined(_SILICON_LABS_32B_SERIES_0)
      ret >>= ((CMU->LFAPRESC0 & _CMU_LFAPRESC0_LCD_MASK)
     b12:	4b33      	ldr	r3, [pc, #204]	; (be0 <CMU_ClockFreqGet+0x1c8>)
     b14:	6e9b      	ldr	r3, [r3, #104]	; 0x68
     b16:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
               >> _CMU_LFAPRESC0_LCD_SHIFT)
     b1a:	0b1c      	lsrs	r4, r3, #12
              + CMU_DivToLog2(cmuClkDiv_16);
     b1c:	2010      	movs	r0, #16
     b1e:	f7ff fd47 	bl	5b0 <CMU_DivToLog2>
     b22:	4603      	mov	r3, r0
     b24:	4423      	add	r3, r4

#if defined(_CMU_LFACLKEN0_LCD_MASK)
    case (CMU_LCDPRE_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = lfClkGet(cmuClock_LFA);
#if defined(_SILICON_LABS_32B_SERIES_0)
      ret >>= ((CMU->LFAPRESC0 & _CMU_LFAPRESC0_LCD_MASK)
     b26:	9a03      	ldr	r2, [sp, #12]
     b28:	fa22 f303 	lsr.w	r3, r2, r3
     b2c:	9303      	str	r3, [sp, #12]
              + CMU_DivToLog2(cmuClkDiv_16);
#else
      ret /= CMU_Log2ToDiv((CMU->LFAPRESC0 & _CMU_LFAPRESC0_LCD_MASK)
                           >> _CMU_LFAPRESC0_LCD_SHIFT);
#endif
      break;
     b2e:	e052      	b.n	bd6 <CMU_ClockFreqGet+0x1be>

#if defined(_CMU_LCDCTRL_MASK)
    case (CMU_LCD_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = lfClkGet(cmuClock_LFA);
     b30:	482c      	ldr	r0, [pc, #176]	; (be4 <CMU_ClockFreqGet+0x1cc>)
     b32:	f7ff fe5b 	bl	7ec <lfClkGet>
     b36:	9003      	str	r0, [sp, #12]
      ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_LCD_MASK)
     b38:	4b29      	ldr	r3, [pc, #164]	; (be0 <CMU_ClockFreqGet+0x1c8>)
     b3a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
     b3c:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
              >> _CMU_LFAPRESC0_LCD_SHIFT;
     b40:	0b1b      	lsrs	r3, r3, #12
      break;

#if defined(_CMU_LCDCTRL_MASK)
    case (CMU_LCD_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = lfClkGet(cmuClock_LFA);
      ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_LCD_MASK)
     b42:	9a03      	ldr	r2, [sp, #12]
     b44:	fa22 f303 	lsr.w	r3, r2, r3
     b48:	9303      	str	r3, [sp, #12]
              >> _CMU_LFAPRESC0_LCD_SHIFT;
      ret /= 1U + ((CMU->LCDCTRL & _CMU_LCDCTRL_FDIV_MASK)
     b4a:	4b25      	ldr	r3, [pc, #148]	; (be0 <CMU_ClockFreqGet+0x1c8>)
     b4c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
                   >> _CMU_LCDCTRL_FDIV_SHIFT);
     b4e:	f003 0307 	and.w	r3, r3, #7
#if defined(_CMU_LCDCTRL_MASK)
    case (CMU_LCD_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = lfClkGet(cmuClock_LFA);
      ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_LCD_MASK)
              >> _CMU_LFAPRESC0_LCD_SHIFT;
      ret /= 1U + ((CMU->LCDCTRL & _CMU_LCDCTRL_FDIV_MASK)
     b52:	3301      	adds	r3, #1
     b54:	9a03      	ldr	r2, [sp, #12]
     b56:	fbb2 f3f3 	udiv	r3, r2, r3
     b5a:	9303      	str	r3, [sp, #12]
                   >> _CMU_LCDCTRL_FDIV_SHIFT);
      break;
     b5c:	e03b      	b.n	bd6 <CMU_ClockFreqGet+0x1be>
#endif
#endif

#if defined(_CMU_LFACLKEN0_LESENSE_MASK)
    case (CMU_LESENSE_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = lfClkGet(cmuClock_LFA);
     b5e:	4821      	ldr	r0, [pc, #132]	; (be4 <CMU_ClockFreqGet+0x1cc>)
     b60:	f7ff fe44 	bl	7ec <lfClkGet>
     b64:	9003      	str	r0, [sp, #12]
      ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_LESENSE_MASK)
     b66:	4b1e      	ldr	r3, [pc, #120]	; (be0 <CMU_ClockFreqGet+0x1c8>)
     b68:	6e9b      	ldr	r3, [r3, #104]	; 0x68
              >> _CMU_LFAPRESC0_LESENSE_SHIFT;
     b6a:	f003 0303 	and.w	r3, r3, #3
#endif

#if defined(_CMU_LFACLKEN0_LESENSE_MASK)
    case (CMU_LESENSE_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = lfClkGet(cmuClock_LFA);
      ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_LESENSE_MASK)
     b6e:	9a03      	ldr	r2, [sp, #12]
     b70:	fa22 f303 	lsr.w	r3, r2, r3
     b74:	9303      	str	r3, [sp, #12]
              >> _CMU_LFAPRESC0_LESENSE_SHIFT;
      break;
     b76:	e02e      	b.n	bd6 <CMU_ClockFreqGet+0x1be>
#endif

    case (CMU_LFB_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = lfClkGet(cmuClock_LFB);
     b78:	481b      	ldr	r0, [pc, #108]	; (be8 <CMU_ClockFreqGet+0x1d0>)
     b7a:	f7ff fe37 	bl	7ec <lfClkGet>
     b7e:	9003      	str	r0, [sp, #12]
      break;
     b80:	e029      	b.n	bd6 <CMU_ClockFreqGet+0x1be>

#if defined(_CMU_LFBCLKEN0_LEUART0_MASK)
    case (CMU_LEUART0_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = lfClkGet(cmuClock_LFB);
     b82:	4819      	ldr	r0, [pc, #100]	; (be8 <CMU_ClockFreqGet+0x1d0>)
     b84:	f7ff fe32 	bl	7ec <lfClkGet>
     b88:	9003      	str	r0, [sp, #12]
#if defined(_SILICON_LABS_32B_SERIES_0)
      ret >>= (CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART0_MASK)
     b8a:	4b15      	ldr	r3, [pc, #84]	; (be0 <CMU_ClockFreqGet+0x1c8>)
     b8c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
              >> _CMU_LFBPRESC0_LEUART0_SHIFT;
     b8e:	f003 0303 	and.w	r3, r3, #3

#if defined(_CMU_LFBCLKEN0_LEUART0_MASK)
    case (CMU_LEUART0_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = lfClkGet(cmuClock_LFB);
#if defined(_SILICON_LABS_32B_SERIES_0)
      ret >>= (CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART0_MASK)
     b92:	9a03      	ldr	r2, [sp, #12]
     b94:	fa22 f303 	lsr.w	r3, r2, r3
     b98:	9303      	str	r3, [sp, #12]
              >> _CMU_LFBPRESC0_LEUART0_SHIFT;
#else
      ret /= CMU_Log2ToDiv((CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART0_MASK)
                           >> _CMU_LFBPRESC0_LEUART0_SHIFT);
#endif
      break;
     b9a:	e01c      	b.n	bd6 <CMU_ClockFreqGet+0x1be>
#endif

#if defined(_CMU_LFBCLKEN0_LEUART1_MASK)
    case (CMU_LEUART1_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = lfClkGet(cmuClock_LFB);
     b9c:	4812      	ldr	r0, [pc, #72]	; (be8 <CMU_ClockFreqGet+0x1d0>)
     b9e:	f7ff fe25 	bl	7ec <lfClkGet>
     ba2:	9003      	str	r0, [sp, #12]
#if defined(_SILICON_LABS_32B_SERIES_0)
      ret >>= (CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART1_MASK)
     ba4:	4b0e      	ldr	r3, [pc, #56]	; (be0 <CMU_ClockFreqGet+0x1c8>)
     ba6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
     ba8:	f003 0330 	and.w	r3, r3, #48	; 0x30
              >> _CMU_LFBPRESC0_LEUART1_SHIFT;
     bac:	091b      	lsrs	r3, r3, #4

#if defined(_CMU_LFBCLKEN0_LEUART1_MASK)
    case (CMU_LEUART1_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = lfClkGet(cmuClock_LFB);
#if defined(_SILICON_LABS_32B_SERIES_0)
      ret >>= (CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART1_MASK)
     bae:	9a03      	ldr	r2, [sp, #12]
     bb0:	fa22 f303 	lsr.w	r3, r2, r3
     bb4:	9303      	str	r3, [sp, #12]
              >> _CMU_LFBPRESC0_LEUART1_SHIFT;
#else
      ret /= CMU_Log2ToDiv((CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART1_MASK)
                           >> _CMU_LFBPRESC0_LEUART1_SHIFT);
#endif
      break;
     bb6:	e00e      	b.n	bd6 <CMU_ClockFreqGet+0x1be>
      ret = lfClkGet(cmuClock_LFE);
      break;
#endif

    case (CMU_DBG_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = dbgClkGet();
     bb8:	f7ff fdf8 	bl	7ac <dbgClkGet>
     bbc:	9003      	str	r0, [sp, #12]
      break;
     bbe:	e00a      	b.n	bd6 <CMU_ClockFreqGet+0x1be>

    case (CMU_AUX_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = auxClkGet();
     bc0:	f7ff fd9c 	bl	6fc <auxClkGet>
     bc4:	9003      	str	r0, [sp, #12]
      break;
     bc6:	e006      	b.n	bd6 <CMU_ClockFreqGet+0x1be>

#if defined(USBC_CLOCK_PRESENT)
    case (CMU_USBC_CLK_BRANCH << CMU_CLK_BRANCH_POS):
      ret = usbCClkGet();
     bc8:	f7ff fe98 	bl	8fc <usbCClkGet>
     bcc:	9003      	str	r0, [sp, #12]
      break;
     bce:	e002      	b.n	bd6 <CMU_ClockFreqGet+0x1be>
      break;
#endif

    default:
      EFM_ASSERT(0);
      ret = 0;
     bd0:	2300      	movs	r3, #0
     bd2:	9303      	str	r3, [sp, #12]
      break;
     bd4:	bf00      	nop
  }

  return ret;
     bd6:	9b03      	ldr	r3, [sp, #12]
}
     bd8:	4618      	mov	r0, r3
     bda:	b004      	add	sp, #16
     bdc:	bd10      	pop	{r4, pc}
     bde:	bf00      	nop
     be0:	400c8000 	.word	0x400c8000
     be4:	001a0002 	.word	0x001a0002
     be8:	001c0003 	.word	0x001c0003

00000bec <CMU_ClockSelectGet>:
 * @return
 *   Reference clock used for clocking selected branch, #cmuSelect_Error if
 *   invalid @p clock provided.
 ******************************************************************************/
CMU_Select_TypeDef CMU_ClockSelectGet(CMU_Clock_TypeDef clock)
{
     bec:	b084      	sub	sp, #16
     bee:	9001      	str	r0, [sp, #4]
  CMU_Select_TypeDef ret = cmuSelect_Disabled;
     bf0:	2301      	movs	r3, #1
     bf2:	f88d 300f 	strb.w	r3, [sp, #15]
  uint32_t selReg;

  selReg = (clock >> CMU_SEL_REG_POS) & CMU_SEL_REG_MASK;
     bf6:	9b01      	ldr	r3, [sp, #4]
     bf8:	f003 030f 	and.w	r3, r3, #15
     bfc:	9302      	str	r3, [sp, #8]

  switch (selReg) {
     bfe:	9b02      	ldr	r3, [sp, #8]
     c00:	3b01      	subs	r3, #1
     c02:	2b06      	cmp	r3, #6
     c04:	f200 80a6 	bhi.w	d54 <Heap_Size+0x154>
     c08:	a201      	add	r2, pc, #4	; (adr r2, c10 <Heap_Size+0x10>)
     c0a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     c0e:	bf00      	nop
     c10:	00000c2d 	.word	0x00000c2d
     c14:	00000c6b 	.word	0x00000c6b
     c18:	00000caf 	.word	0x00000caf
     c1c:	00000d55 	.word	0x00000d55
     c20:	00000d55 	.word	0x00000d55
     c24:	00000cf3 	.word	0x00000cf3
     c28:	00000d19 	.word	0x00000d19
        default:
          ret = cmuSelect_HFRCO;
          break;
      }
#else
      switch (CMU->STATUS
     c2c:	4b4e      	ldr	r3, [pc, #312]	; (d68 <Heap_Size+0x168>)
     c2e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
              & (CMU_STATUS_HFRCOSEL
     c30:	f403 5370 	and.w	r3, r3, #15360	; 0x3c00
        default:
          ret = cmuSelect_HFRCO;
          break;
      }
#else
      switch (CMU->STATUS
     c34:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
     c38:	d00a      	beq.n	c50 <Heap_Size+0x50>
     c3a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
     c3e:	d003      	beq.n	c48 <Heap_Size+0x48>
     c40:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
     c44:	d008      	beq.n	c58 <Heap_Size+0x58>
     c46:	e00b      	b.n	c60 <Heap_Size+0x60>
#if defined(CMU_STATUS_USHFRCODIV2SEL)
                 | CMU_STATUS_USHFRCODIV2SEL
#endif
                 | CMU_STATUS_LFXOSEL)) {
        case CMU_STATUS_LFXOSEL:
          ret = cmuSelect_LFXO;
     c48:	2302      	movs	r3, #2
     c4a:	f88d 300f 	strb.w	r3, [sp, #15]
          break;
     c4e:	e00b      	b.n	c68 <Heap_Size+0x68>

        case CMU_STATUS_LFRCOSEL:
          ret = cmuSelect_LFRCO;
     c50:	2303      	movs	r3, #3
     c52:	f88d 300f 	strb.w	r3, [sp, #15]
          break;
     c56:	e007      	b.n	c68 <Heap_Size+0x68>

        case CMU_STATUS_HFXOSEL:
          ret = cmuSelect_HFXO;
     c58:	2304      	movs	r3, #4
     c5a:	f88d 300f 	strb.w	r3, [sp, #15]
          break;
     c5e:	e003      	b.n	c68 <Heap_Size+0x68>
          ret = cmuSelect_USHFRCODIV2;
          break;
#endif

        default:
          ret = cmuSelect_HFRCO;
     c60:	2305      	movs	r3, #5
     c62:	f88d 300f 	strb.w	r3, [sp, #15]
          break;
     c66:	bf00      	nop
      }
#endif
      break;
     c68:	e078      	b.n	d5c <Heap_Size+0x15c>

#if defined(_CMU_LFCLKSEL_MASK) || defined(_CMU_LFACLKSEL_MASK)
    case CMU_LFACLKSEL_REG:
#if defined(_CMU_LFCLKSEL_MASK)
      switch (CMU->LFCLKSEL & _CMU_LFCLKSEL_LFA_MASK) {
     c6a:	4b3f      	ldr	r3, [pc, #252]	; (d68 <Heap_Size+0x168>)
     c6c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     c6e:	f003 0303 	and.w	r3, r3, #3
     c72:	2b02      	cmp	r3, #2
     c74:	d007      	beq.n	c86 <Heap_Size+0x86>
     c76:	2b03      	cmp	r3, #3
     c78:	d009      	beq.n	c8e <Heap_Size+0x8e>
     c7a:	2b01      	cmp	r3, #1
     c7c:	d10b      	bne.n	c96 <Heap_Size+0x96>
        case CMU_LFCLKSEL_LFA_LFRCO:
          ret = cmuSelect_LFRCO;
     c7e:	2303      	movs	r3, #3
     c80:	f88d 300f 	strb.w	r3, [sp, #15]
          break;
     c84:	e012      	b.n	cac <Heap_Size+0xac>

        case CMU_LFCLKSEL_LFA_LFXO:
          ret = cmuSelect_LFXO;
     c86:	2302      	movs	r3, #2
     c88:	f88d 300f 	strb.w	r3, [sp, #15]
          break;
     c8c:	e00e      	b.n	cac <Heap_Size+0xac>

#if defined(CMU_LFCLKSEL_LFA_HFCORECLKLEDIV2)
        case CMU_LFCLKSEL_LFA_HFCORECLKLEDIV2:
          ret = cmuSelect_HFCLKLE;
     c8e:	2306      	movs	r3, #6
     c90:	f88d 300f 	strb.w	r3, [sp, #15]
          break;
     c94:	e00a      	b.n	cac <Heap_Size+0xac>
#endif

        default:
#if defined(CMU_LFCLKSEL_LFAE)
          if (CMU->LFCLKSEL & _CMU_LFCLKSEL_LFAE_MASK) {
     c96:	4b34      	ldr	r3, [pc, #208]	; (d68 <Heap_Size+0x168>)
     c98:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     c9a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
     c9e:	2b00      	cmp	r3, #0
     ca0:	d003      	beq.n	caa <Heap_Size+0xaa>
            ret = cmuSelect_ULFRCO;
     ca2:	230a      	movs	r3, #10
     ca4:	f88d 300f 	strb.w	r3, [sp, #15]
            break;
     ca8:	e000      	b.n	cac <Heap_Size+0xac>
          }
#else
          ret = cmuSelect_Disabled;
#endif
          break;
     caa:	bf00      	nop
        default:
          ret = cmuSelect_Disabled;
          break;
      }
#endif
      break;
     cac:	e056      	b.n	d5c <Heap_Size+0x15c>
#endif /* _CMU_LFCLKSEL_MASK || _CMU_LFACLKSEL_MASK */

#if defined(_CMU_LFCLKSEL_MASK) || defined(_CMU_LFBCLKSEL_MASK)
    case CMU_LFBCLKSEL_REG:
#if defined(_CMU_LFCLKSEL_MASK)
      switch (CMU->LFCLKSEL & _CMU_LFCLKSEL_LFB_MASK) {
     cae:	4b2e      	ldr	r3, [pc, #184]	; (d68 <Heap_Size+0x168>)
     cb0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     cb2:	f003 030c 	and.w	r3, r3, #12
     cb6:	2b08      	cmp	r3, #8
     cb8:	d007      	beq.n	cca <Heap_Size+0xca>
     cba:	2b0c      	cmp	r3, #12
     cbc:	d009      	beq.n	cd2 <Heap_Size+0xd2>
     cbe:	2b04      	cmp	r3, #4
     cc0:	d10b      	bne.n	cda <Heap_Size+0xda>
        case CMU_LFCLKSEL_LFB_LFRCO:
          ret = cmuSelect_LFRCO;
     cc2:	2303      	movs	r3, #3
     cc4:	f88d 300f 	strb.w	r3, [sp, #15]
          break;
     cc8:	e012      	b.n	cf0 <Heap_Size+0xf0>

        case CMU_LFCLKSEL_LFB_LFXO:
          ret = cmuSelect_LFXO;
     cca:	2302      	movs	r3, #2
     ccc:	f88d 300f 	strb.w	r3, [sp, #15]
          break;
     cd0:	e00e      	b.n	cf0 <Heap_Size+0xf0>

#if defined(CMU_LFCLKSEL_LFB_HFCORECLKLEDIV2)
        case CMU_LFCLKSEL_LFB_HFCORECLKLEDIV2:
          ret = cmuSelect_HFCLKLE;
     cd2:	2306      	movs	r3, #6
     cd4:	f88d 300f 	strb.w	r3, [sp, #15]
          break;
     cd8:	e00a      	b.n	cf0 <Heap_Size+0xf0>
          break;
#endif

        default:
#if defined(CMU_LFCLKSEL_LFBE)
          if (CMU->LFCLKSEL & _CMU_LFCLKSEL_LFBE_MASK) {
     cda:	4b23      	ldr	r3, [pc, #140]	; (d68 <Heap_Size+0x168>)
     cdc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     cde:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
     ce2:	2b00      	cmp	r3, #0
     ce4:	d003      	beq.n	cee <Heap_Size+0xee>
            ret = cmuSelect_ULFRCO;
     ce6:	230a      	movs	r3, #10
     ce8:	f88d 300f 	strb.w	r3, [sp, #15]
            break;
     cec:	e000      	b.n	cf0 <Heap_Size+0xf0>
          }
#else
          ret = cmuSelect_Disabled;
#endif
          break;
     cee:	bf00      	nop
        default:
          ret = cmuSelect_Disabled;
          break;
      }
#endif
      break;
     cf0:	e034      	b.n	d5c <Heap_Size+0x15c>
          ret = cmuSelect_AUXHFRCO;
          break;
      }

#elif defined(_CMU_CTRL_DBGCLK_MASK)
      switch (CMU->CTRL & _CMU_CTRL_DBGCLK_MASK) {
     cf2:	4b1d      	ldr	r3, [pc, #116]	; (d68 <Heap_Size+0x168>)
     cf4:	681b      	ldr	r3, [r3, #0]
     cf6:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
     cfa:	2b00      	cmp	r3, #0
     cfc:	d003      	beq.n	d06 <Heap_Size+0x106>
     cfe:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
     d02:	d004      	beq.n	d0e <Heap_Size+0x10e>
          break;
      }
#else
      ret = cmuSelect_AUXHFRCO;
#endif
      break;
     d04:	e02a      	b.n	d5c <Heap_Size+0x15c>
      }

#elif defined(_CMU_CTRL_DBGCLK_MASK)
      switch (CMU->CTRL & _CMU_CTRL_DBGCLK_MASK) {
        case CMU_CTRL_DBGCLK_AUXHFRCO:
          ret = cmuSelect_AUXHFRCO;
     d06:	2307      	movs	r3, #7
     d08:	f88d 300f 	strb.w	r3, [sp, #15]
          break;
     d0c:	e003      	b.n	d16 <Heap_Size+0x116>

        case CMU_CTRL_DBGCLK_HFCLK:
          ret = cmuSelect_HFCLK;
     d0e:	2309      	movs	r3, #9
     d10:	f88d 300f 	strb.w	r3, [sp, #15]
          break;
     d14:	bf00      	nop
      }
#else
      ret = cmuSelect_AUXHFRCO;
#endif
      break;
     d16:	e021      	b.n	d5c <Heap_Size+0x15c>

#if defined(USBC_CLOCK_PRESENT)
    case CMU_USBCCLKSEL_REG:
      switch (CMU->STATUS
     d18:	4b13      	ldr	r3, [pc, #76]	; (d68 <Heap_Size+0x168>)
     d1a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
              & (CMU_STATUS_USBCLFXOSEL
     d1c:	f403 3360 	and.w	r3, r3, #229376	; 0x38000
#endif
      break;

#if defined(USBC_CLOCK_PRESENT)
    case CMU_USBCCLKSEL_REG:
      switch (CMU->STATUS
     d20:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
     d24:	d009      	beq.n	d3a <Heap_Size+0x13a>
     d26:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
     d2a:	d00a      	beq.n	d42 <Heap_Size+0x142>
     d2c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
     d30:	d10b      	bne.n	d4a <Heap_Size+0x14a>
                 | CMU_STATUS_USBCUSHFRCOSEL
#endif
                 | CMU_STATUS_USBCLFRCOSEL)) {
#if defined(_CMU_STATUS_USBCHFCLKSEL_MASK)
        case CMU_STATUS_USBCHFCLKSEL:
          ret = cmuSelect_HFCLK;
     d32:	2309      	movs	r3, #9
     d34:	f88d 300f 	strb.w	r3, [sp, #15]
          break;
     d38:	e00b      	b.n	d52 <Heap_Size+0x152>
          ret = cmuSelect_USHFRCO;
          break;
#endif

        case CMU_STATUS_USBCLFXOSEL:
          ret = cmuSelect_LFXO;
     d3a:	2302      	movs	r3, #2
     d3c:	f88d 300f 	strb.w	r3, [sp, #15]
          break;
     d40:	e007      	b.n	d52 <Heap_Size+0x152>

        case CMU_STATUS_USBCLFRCOSEL:
          ret = cmuSelect_LFRCO;
     d42:	2303      	movs	r3, #3
     d44:	f88d 300f 	strb.w	r3, [sp, #15]
          break;
     d48:	e003      	b.n	d52 <Heap_Size+0x152>

        default:
          ret = cmuSelect_Disabled;
     d4a:	2301      	movs	r3, #1
     d4c:	f88d 300f 	strb.w	r3, [sp, #15]
          break;
     d50:	bf00      	nop
      }
      break;
     d52:	e003      	b.n	d5c <Heap_Size+0x15c>
      break;
#endif

    default:
      EFM_ASSERT(0);
      ret = cmuSelect_Error;
     d54:	2300      	movs	r3, #0
     d56:	f88d 300f 	strb.w	r3, [sp, #15]
      break;
     d5a:	bf00      	nop
  }

  return ret;
     d5c:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
     d60:	4618      	mov	r0, r3
     d62:	b004      	add	sp, #16
     d64:	4770      	bx	lr
     d66:	bf00      	nop
     d68:	400c8000 	.word	0x400c8000

00000d6c <GPIO_PinOutClear>:
 *
 * @param[in] pin
 *   The pin to set.
 ******************************************************************************/
__STATIC_INLINE void GPIO_PinOutClear(GPIO_Port_TypeDef port, unsigned int pin)
{
     d6c:	b082      	sub	sp, #8
     d6e:	4603      	mov	r3, r0
     d70:	9100      	str	r1, [sp, #0]
     d72:	f88d 3007 	strb.w	r3, [sp, #7]
  EFM_ASSERT(GPIO_PORT_PIN_VALID(port, pin));
     d76:	f89d 3007 	ldrb.w	r3, [sp, #7]
     d7a:	2b00      	cmp	r3, #0
     d7c:	d012      	beq.n	da4 <GPIO_PinOutClear+0x38>
     d7e:	f89d 3007 	ldrb.w	r3, [sp, #7]
     d82:	2b01      	cmp	r3, #1
     d84:	d00e      	beq.n	da4 <GPIO_PinOutClear+0x38>
     d86:	f89d 3007 	ldrb.w	r3, [sp, #7]
     d8a:	2b02      	cmp	r3, #2
     d8c:	d00a      	beq.n	da4 <GPIO_PinOutClear+0x38>
     d8e:	f89d 3007 	ldrb.w	r3, [sp, #7]
     d92:	2b03      	cmp	r3, #3
     d94:	d006      	beq.n	da4 <GPIO_PinOutClear+0x38>
     d96:	f89d 3007 	ldrb.w	r3, [sp, #7]
     d9a:	2b04      	cmp	r3, #4
     d9c:	d002      	beq.n	da4 <GPIO_PinOutClear+0x38>
     d9e:	f89d 3007 	ldrb.w	r3, [sp, #7]
     da2:	2b05      	cmp	r3, #5
#if defined(_GPIO_P_DOUTCLR_MASK)
  GPIO->P[port].DOUTCLR = 1 << pin;
     da4:	4908      	ldr	r1, [pc, #32]	; (dc8 <GPIO_PinOutClear+0x5c>)
     da6:	f89d 2007 	ldrb.w	r2, [sp, #7]
     daa:	2001      	movs	r0, #1
     dac:	9b00      	ldr	r3, [sp, #0]
     dae:	fa00 f303 	lsl.w	r3, r0, r3
     db2:	4618      	mov	r0, r3
     db4:	4613      	mov	r3, r2
     db6:	00db      	lsls	r3, r3, #3
     db8:	4413      	add	r3, r2
     dba:	009b      	lsls	r3, r3, #2
     dbc:	440b      	add	r3, r1
     dbe:	3314      	adds	r3, #20
     dc0:	6018      	str	r0, [r3, #0]
#else
  BUS_RegMaskedClear(&GPIO->P[port].DOUT, 1 << pin);
#endif
}
     dc2:	bf00      	nop
     dc4:	b002      	add	sp, #8
     dc6:	4770      	bx	lr
     dc8:	40006000 	.word	0x40006000

00000dcc <GPIO_PinOutSet>:
 *
 * @param[in] pin
 *   The pin to set.
 ******************************************************************************/
__STATIC_INLINE void GPIO_PinOutSet(GPIO_Port_TypeDef port, unsigned int pin)
{
     dcc:	b082      	sub	sp, #8
     dce:	4603      	mov	r3, r0
     dd0:	9100      	str	r1, [sp, #0]
     dd2:	f88d 3007 	strb.w	r3, [sp, #7]
  EFM_ASSERT(GPIO_PORT_PIN_VALID(port, pin));
     dd6:	f89d 3007 	ldrb.w	r3, [sp, #7]
     dda:	2b00      	cmp	r3, #0
     ddc:	d012      	beq.n	e04 <GPIO_PinOutSet+0x38>
     dde:	f89d 3007 	ldrb.w	r3, [sp, #7]
     de2:	2b01      	cmp	r3, #1
     de4:	d00e      	beq.n	e04 <GPIO_PinOutSet+0x38>
     de6:	f89d 3007 	ldrb.w	r3, [sp, #7]
     dea:	2b02      	cmp	r3, #2
     dec:	d00a      	beq.n	e04 <GPIO_PinOutSet+0x38>
     dee:	f89d 3007 	ldrb.w	r3, [sp, #7]
     df2:	2b03      	cmp	r3, #3
     df4:	d006      	beq.n	e04 <GPIO_PinOutSet+0x38>
     df6:	f89d 3007 	ldrb.w	r3, [sp, #7]
     dfa:	2b04      	cmp	r3, #4
     dfc:	d002      	beq.n	e04 <GPIO_PinOutSet+0x38>
     dfe:	f89d 3007 	ldrb.w	r3, [sp, #7]
     e02:	2b05      	cmp	r3, #5
#if defined(_GPIO_P_DOUTSET_MASK)
  GPIO->P[port].DOUTSET = 1 << pin;
     e04:	4908      	ldr	r1, [pc, #32]	; (e28 <GPIO_PinOutSet+0x5c>)
     e06:	f89d 2007 	ldrb.w	r2, [sp, #7]
     e0a:	2001      	movs	r0, #1
     e0c:	9b00      	ldr	r3, [sp, #0]
     e0e:	fa00 f303 	lsl.w	r3, r0, r3
     e12:	4618      	mov	r0, r3
     e14:	4613      	mov	r3, r2
     e16:	00db      	lsls	r3, r3, #3
     e18:	4413      	add	r3, r2
     e1a:	009b      	lsls	r3, r3, #2
     e1c:	440b      	add	r3, r1
     e1e:	3310      	adds	r3, #16
     e20:	6018      	str	r0, [r3, #0]
#else
  BUS_RegMaskedSet(&GPIO->P[port].DOUT, 1 << pin);
#endif
}
     e22:	bf00      	nop
     e24:	b002      	add	sp, #8
     e26:	4770      	bx	lr
     e28:	40006000 	.word	0x40006000

00000e2c <GPIO_PinModeSet>:
 ******************************************************************************/
void GPIO_PinModeSet(GPIO_Port_TypeDef port,
                     unsigned int pin,
                     GPIO_Mode_TypeDef mode,
                     unsigned int out)
{
     e2c:	b510      	push	{r4, lr}
     e2e:	b084      	sub	sp, #16
     e30:	9102      	str	r1, [sp, #8]
     e32:	9301      	str	r3, [sp, #4]
     e34:	4603      	mov	r3, r0
     e36:	f88d 300f 	strb.w	r3, [sp, #15]
     e3a:	4613      	mov	r3, r2
     e3c:	f88d 300e 	strb.w	r3, [sp, #14]
  EFM_ASSERT(GPIO_PORT_PIN_VALID(port, pin));
     e40:	f89d 300f 	ldrb.w	r3, [sp, #15]
     e44:	2b00      	cmp	r3, #0
     e46:	d012      	beq.n	e6e <GPIO_PinModeSet+0x42>
     e48:	f89d 300f 	ldrb.w	r3, [sp, #15]
     e4c:	2b01      	cmp	r3, #1
     e4e:	d00e      	beq.n	e6e <GPIO_PinModeSet+0x42>
     e50:	f89d 300f 	ldrb.w	r3, [sp, #15]
     e54:	2b02      	cmp	r3, #2
     e56:	d00a      	beq.n	e6e <GPIO_PinModeSet+0x42>
     e58:	f89d 300f 	ldrb.w	r3, [sp, #15]
     e5c:	2b03      	cmp	r3, #3
     e5e:	d006      	beq.n	e6e <GPIO_PinModeSet+0x42>
     e60:	f89d 300f 	ldrb.w	r3, [sp, #15]
     e64:	2b04      	cmp	r3, #4
     e66:	d002      	beq.n	e6e <GPIO_PinModeSet+0x42>
     e68:	f89d 300f 	ldrb.w	r3, [sp, #15]
     e6c:	2b05      	cmp	r3, #5

  /* If disabling pin, do not modify DOUT in order to reduce chance for */
  /* glitch/spike (may not be sufficient precaution in all use cases) */
  if (mode != gpioModeDisabled) {
     e6e:	f89d 300e 	ldrb.w	r3, [sp, #14]
     e72:	2b00      	cmp	r3, #0
     e74:	d00f      	beq.n	e96 <GPIO_PinModeSet+0x6a>
    if (out) {
     e76:	9b01      	ldr	r3, [sp, #4]
     e78:	2b00      	cmp	r3, #0
     e7a:	d006      	beq.n	e8a <GPIO_PinModeSet+0x5e>
      GPIO_PinOutSet(port, pin);
     e7c:	f89d 300f 	ldrb.w	r3, [sp, #15]
     e80:	9902      	ldr	r1, [sp, #8]
     e82:	4618      	mov	r0, r3
     e84:	f7ff ffa2 	bl	dcc <GPIO_PinOutSet>
     e88:	e005      	b.n	e96 <GPIO_PinModeSet+0x6a>
    } else {
      GPIO_PinOutClear(port, pin);
     e8a:	f89d 300f 	ldrb.w	r3, [sp, #15]
     e8e:	9902      	ldr	r1, [sp, #8]
     e90:	4618      	mov	r0, r3
     e92:	f7ff ff6b 	bl	d6c <GPIO_PinOutClear>
    }
  }

  /* There are two registers controlling the pins for each port. The MODEL
   * register controls pins 0-7 and MODEH controls pins 8-15. */
  if (pin < 8) {
     e96:	9b02      	ldr	r3, [sp, #8]
     e98:	2b07      	cmp	r3, #7
     e9a:	d822      	bhi.n	ee2 <GPIO_PinModeSet+0xb6>
    GPIO->P[port].MODEL = (GPIO->P[port].MODEL & ~(0xFu << (pin * 4)))
     e9c:	4c30      	ldr	r4, [pc, #192]	; (f60 <GPIO_PinModeSet+0x134>)
     e9e:	f89d 200f 	ldrb.w	r2, [sp, #15]
     ea2:	482f      	ldr	r0, [pc, #188]	; (f60 <GPIO_PinModeSet+0x134>)
     ea4:	f89d 100f 	ldrb.w	r1, [sp, #15]
     ea8:	460b      	mov	r3, r1
     eaa:	00db      	lsls	r3, r3, #3
     eac:	440b      	add	r3, r1
     eae:	009b      	lsls	r3, r3, #2
     eb0:	4403      	add	r3, r0
     eb2:	3304      	adds	r3, #4
     eb4:	6819      	ldr	r1, [r3, #0]
     eb6:	9b02      	ldr	r3, [sp, #8]
     eb8:	009b      	lsls	r3, r3, #2
     eba:	200f      	movs	r0, #15
     ebc:	fa00 f303 	lsl.w	r3, r0, r3
     ec0:	43db      	mvns	r3, r3
     ec2:	400b      	ands	r3, r1
                          | (mode << (pin * 4));
     ec4:	f89d 000e 	ldrb.w	r0, [sp, #14]
     ec8:	9902      	ldr	r1, [sp, #8]
     eca:	0089      	lsls	r1, r1, #2
     ecc:	fa00 f101 	lsl.w	r1, r0, r1
     ed0:	4319      	orrs	r1, r3
  }

  /* There are two registers controlling the pins for each port. The MODEL
   * register controls pins 0-7 and MODEH controls pins 8-15. */
  if (pin < 8) {
    GPIO->P[port].MODEL = (GPIO->P[port].MODEL & ~(0xFu << (pin * 4)))
     ed2:	4613      	mov	r3, r2
     ed4:	00db      	lsls	r3, r3, #3
     ed6:	4413      	add	r3, r2
     ed8:	009b      	lsls	r3, r3, #2
     eda:	4423      	add	r3, r4
     edc:	3304      	adds	r3, #4
     ede:	6019      	str	r1, [r3, #0]
     ee0:	e027      	b.n	f32 <GPIO_PinModeSet+0x106>
                          | (mode << (pin * 4));
  } else {
    GPIO->P[port].MODEH = (GPIO->P[port].MODEH & ~(0xFu << ((pin - 8) * 4)))
     ee2:	4c1f      	ldr	r4, [pc, #124]	; (f60 <GPIO_PinModeSet+0x134>)
     ee4:	f89d 200f 	ldrb.w	r2, [sp, #15]
     ee8:	481d      	ldr	r0, [pc, #116]	; (f60 <GPIO_PinModeSet+0x134>)
     eea:	f89d 100f 	ldrb.w	r1, [sp, #15]
     eee:	460b      	mov	r3, r1
     ef0:	00db      	lsls	r3, r3, #3
     ef2:	440b      	add	r3, r1
     ef4:	009b      	lsls	r3, r3, #2
     ef6:	4403      	add	r3, r0
     ef8:	3308      	adds	r3, #8
     efa:	6819      	ldr	r1, [r3, #0]
     efc:	9b02      	ldr	r3, [sp, #8]
     efe:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
     f02:	3b08      	subs	r3, #8
     f04:	009b      	lsls	r3, r3, #2
     f06:	200f      	movs	r0, #15
     f08:	fa00 f303 	lsl.w	r3, r0, r3
     f0c:	43db      	mvns	r3, r3
     f0e:	4019      	ands	r1, r3
                          | (mode << ((pin - 8) * 4));
     f10:	f89d 000e 	ldrb.w	r0, [sp, #14]
     f14:	9b02      	ldr	r3, [sp, #8]
     f16:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
     f1a:	3b08      	subs	r3, #8
     f1c:	009b      	lsls	r3, r3, #2
     f1e:	fa00 f303 	lsl.w	r3, r0, r3
     f22:	4319      	orrs	r1, r3
   * register controls pins 0-7 and MODEH controls pins 8-15. */
  if (pin < 8) {
    GPIO->P[port].MODEL = (GPIO->P[port].MODEL & ~(0xFu << (pin * 4)))
                          | (mode << (pin * 4));
  } else {
    GPIO->P[port].MODEH = (GPIO->P[port].MODEH & ~(0xFu << ((pin - 8) * 4)))
     f24:	4613      	mov	r3, r2
     f26:	00db      	lsls	r3, r3, #3
     f28:	4413      	add	r3, r2
     f2a:	009b      	lsls	r3, r3, #2
     f2c:	4423      	add	r3, r4
     f2e:	3308      	adds	r3, #8
     f30:	6019      	str	r1, [r3, #0]
                          | (mode << ((pin - 8) * 4));
  }

  if (mode == gpioModeDisabled) {
     f32:	f89d 300e 	ldrb.w	r3, [sp, #14]
     f36:	2b00      	cmp	r3, #0
     f38:	d10f      	bne.n	f5a <GPIO_PinModeSet+0x12e>
    if (out) {
     f3a:	9b01      	ldr	r3, [sp, #4]
     f3c:	2b00      	cmp	r3, #0
     f3e:	d006      	beq.n	f4e <GPIO_PinModeSet+0x122>
      GPIO_PinOutSet(port, pin);
     f40:	f89d 300f 	ldrb.w	r3, [sp, #15]
     f44:	9902      	ldr	r1, [sp, #8]
     f46:	4618      	mov	r0, r3
     f48:	f7ff ff40 	bl	dcc <GPIO_PinOutSet>
    } else {
      GPIO_PinOutClear(port, pin);
    }
  }
}
     f4c:	e005      	b.n	f5a <GPIO_PinModeSet+0x12e>

  if (mode == gpioModeDisabled) {
    if (out) {
      GPIO_PinOutSet(port, pin);
    } else {
      GPIO_PinOutClear(port, pin);
     f4e:	f89d 300f 	ldrb.w	r3, [sp, #15]
     f52:	9902      	ldr	r1, [sp, #8]
     f54:	4618      	mov	r0, r3
     f56:	f7ff ff09 	bl	d6c <GPIO_PinOutClear>
    }
  }
}
     f5a:	bf00      	nop
     f5c:	b004      	add	sp, #16
     f5e:	bd10      	pop	{r4, pc}
     f60:	40006000 	.word	0x40006000

00000f64 <SYSTEM_ChipRevisionGet>:
 *
 * @param[out] rev
 *   Location to place chip revision info.
 ******************************************************************************/
void SYSTEM_ChipRevisionGet(SYSTEM_ChipRevision_TypeDef *rev)
{
     f64:	b084      	sub	sp, #16
     f66:	9001      	str	r0, [sp, #4]
  uint8_t tmp;

  EFM_ASSERT(rev);

  /* CHIP FAMILY bit [5:2] */
  tmp  = (((ROMTABLE->PID1 & _ROMTABLE_PID1_FAMILYMSB_MASK) >> _ROMTABLE_PID1_FAMILYMSB_SHIFT) << 2);
     f68:	4b1c      	ldr	r3, [pc, #112]	; (fdc <SYSTEM_ChipRevisionGet+0x78>)
     f6a:	695b      	ldr	r3, [r3, #20]
     f6c:	b2db      	uxtb	r3, r3
     f6e:	f003 030f 	and.w	r3, r3, #15
     f72:	b2db      	uxtb	r3, r3
     f74:	009b      	lsls	r3, r3, #2
     f76:	f88d 300f 	strb.w	r3, [sp, #15]
  /* CHIP FAMILY bit [1:0] */
  tmp |=  ((ROMTABLE->PID0 & _ROMTABLE_PID0_FAMILYLSB_MASK) >> _ROMTABLE_PID0_FAMILYLSB_SHIFT);
     f7a:	4b18      	ldr	r3, [pc, #96]	; (fdc <SYSTEM_ChipRevisionGet+0x78>)
     f7c:	691b      	ldr	r3, [r3, #16]
     f7e:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
     f82:	099b      	lsrs	r3, r3, #6
     f84:	b2da      	uxtb	r2, r3
     f86:	f89d 300f 	ldrb.w	r3, [sp, #15]
     f8a:	4313      	orrs	r3, r2
     f8c:	f88d 300f 	strb.w	r3, [sp, #15]
  rev->family = tmp;
     f90:	9b01      	ldr	r3, [sp, #4]
     f92:	f89d 200f 	ldrb.w	r2, [sp, #15]
     f96:	709a      	strb	r2, [r3, #2]

  /* CHIP MAJOR bit [3:0] */
  rev->major = (ROMTABLE->PID0 & _ROMTABLE_PID0_REVMAJOR_MASK) >> _ROMTABLE_PID0_REVMAJOR_SHIFT;
     f98:	4b10      	ldr	r3, [pc, #64]	; (fdc <SYSTEM_ChipRevisionGet+0x78>)
     f9a:	691b      	ldr	r3, [r3, #16]
     f9c:	b2db      	uxtb	r3, r3
     f9e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
     fa2:	b2da      	uxtb	r2, r3
     fa4:	9b01      	ldr	r3, [sp, #4]
     fa6:	705a      	strb	r2, [r3, #1]

  /* CHIP MINOR bit [7:4] */
  tmp  = (((ROMTABLE->PID2 & _ROMTABLE_PID2_REVMINORMSB_MASK) >> _ROMTABLE_PID2_REVMINORMSB_SHIFT) << 4);
     fa8:	4b0c      	ldr	r3, [pc, #48]	; (fdc <SYSTEM_ChipRevisionGet+0x78>)
     faa:	699b      	ldr	r3, [r3, #24]
     fac:	b2db      	uxtb	r3, r3
     fae:	f023 030f 	bic.w	r3, r3, #15
     fb2:	f88d 300f 	strb.w	r3, [sp, #15]
  /* CHIP MINOR bit [3:0] */
  tmp |=  ((ROMTABLE->PID3 & _ROMTABLE_PID3_REVMINORLSB_MASK) >> _ROMTABLE_PID3_REVMINORLSB_SHIFT);
     fb6:	4b09      	ldr	r3, [pc, #36]	; (fdc <SYSTEM_ChipRevisionGet+0x78>)
     fb8:	69db      	ldr	r3, [r3, #28]
     fba:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
     fbe:	091b      	lsrs	r3, r3, #4
     fc0:	b2da      	uxtb	r2, r3
     fc2:	f89d 300f 	ldrb.w	r3, [sp, #15]
     fc6:	4313      	orrs	r3, r2
     fc8:	f88d 300f 	strb.w	r3, [sp, #15]
  rev->minor = tmp;
     fcc:	9b01      	ldr	r3, [sp, #4]
     fce:	f89d 200f 	ldrb.w	r2, [sp, #15]
     fd2:	701a      	strb	r2, [r3, #0]
}
     fd4:	bf00      	nop
     fd6:	b004      	add	sp, #16
     fd8:	4770      	bx	lr
     fda:	bf00      	nop
     fdc:	e00fffd0 	.word	0xe00fffd0

00000fe0 <exit>:
     fe0:	b508      	push	{r3, lr}
     fe2:	4b07      	ldr	r3, [pc, #28]	; (1000 <exit+0x20>)
     fe4:	4604      	mov	r4, r0
     fe6:	b113      	cbz	r3, fee <exit+0xe>
     fe8:	2100      	movs	r1, #0
     fea:	f3af 8000 	nop.w
     fee:	4b05      	ldr	r3, [pc, #20]	; (1004 <exit+0x24>)
     ff0:	6818      	ldr	r0, [r3, #0]
     ff2:	6a83      	ldr	r3, [r0, #40]	; 0x28
     ff4:	b103      	cbz	r3, ff8 <exit+0x18>
     ff6:	4798      	blx	r3
     ff8:	4620      	mov	r0, r4
     ffa:	f000 f833 	bl	1064 <_exit>
     ffe:	bf00      	nop
    1000:	00000000 	.word	0x00000000
    1004:	00001080 	.word	0x00001080

00001008 <__libc_init_array>:
    1008:	4b0e      	ldr	r3, [pc, #56]	; (1044 <__libc_init_array+0x3c>)
    100a:	b570      	push	{r4, r5, r6, lr}
    100c:	461e      	mov	r6, r3
    100e:	4c0e      	ldr	r4, [pc, #56]	; (1048 <__libc_init_array+0x40>)
    1010:	2500      	movs	r5, #0
    1012:	1ae4      	subs	r4, r4, r3
    1014:	10a4      	asrs	r4, r4, #2
    1016:	42a5      	cmp	r5, r4
    1018:	d004      	beq.n	1024 <__libc_init_array+0x1c>
    101a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    101e:	4798      	blx	r3
    1020:	3501      	adds	r5, #1
    1022:	e7f8      	b.n	1016 <__libc_init_array+0xe>
    1024:	f000 f820 	bl	1068 <_init>
    1028:	4b08      	ldr	r3, [pc, #32]	; (104c <__libc_init_array+0x44>)
    102a:	4c09      	ldr	r4, [pc, #36]	; (1050 <__libc_init_array+0x48>)
    102c:	461e      	mov	r6, r3
    102e:	1ae4      	subs	r4, r4, r3
    1030:	10a4      	asrs	r4, r4, #2
    1032:	2500      	movs	r5, #0
    1034:	42a5      	cmp	r5, r4
    1036:	d004      	beq.n	1042 <__libc_init_array+0x3a>
    1038:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    103c:	4798      	blx	r3
    103e:	3501      	adds	r5, #1
    1040:	e7f8      	b.n	1034 <__libc_init_array+0x2c>
    1042:	bd70      	pop	{r4, r5, r6, pc}
    1044:	2000006c 	.word	0x2000006c
    1048:	2000006c 	.word	0x2000006c
    104c:	2000006c 	.word	0x2000006c
    1050:	20000070 	.word	0x20000070

00001054 <memset>:
    1054:	4603      	mov	r3, r0
    1056:	4402      	add	r2, r0
    1058:	4293      	cmp	r3, r2
    105a:	d002      	beq.n	1062 <memset+0xe>
    105c:	f803 1b01 	strb.w	r1, [r3], #1
    1060:	e7fa      	b.n	1058 <memset+0x4>
    1062:	4770      	bx	lr

00001064 <_exit>:
    1064:	e7fe      	b.n	1064 <_exit>
    1066:	bf00      	nop

00001068 <_init>:
    1068:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    106a:	bf00      	nop
    106c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    106e:	bc08      	pop	{r3}
    1070:	469e      	mov	lr, r3
    1072:	4770      	bx	lr

00001074 <_fini>:
    1074:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1076:	bf00      	nop
    1078:	bcf8      	pop	{r3, r4, r5, r6, r7}
    107a:	bc08      	pop	{r3}
    107c:	469e      	mov	lr, r3
    107e:	4770      	bx	lr

00001080 <_global_impure_ptr>:
    1080:	000c 2000                                   ... 

00001084 <__EH_FRAME_BEGIN__>:
    1084:	0000 0000                                   ....
